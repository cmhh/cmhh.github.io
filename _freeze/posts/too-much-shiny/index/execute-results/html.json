{
  "hash": "6ba826d556e75808062eb9ae6c727e66",
  "result": {
    "markdown": "---\ntitle: Too Much Shiny?!\nauthor: Chris Hansen\ndate: '2022-01-20'\ncategories: [R, shiny, single-page web apps]\ntags: [R, shiny, single-page web apps]\narchives: '2022'\n---\n\n<link rel=\"stylesheet\" href=\"assets/css/vue-slider-component.min.css\">\n<script src=\"assets/js/vue@2.6.14.js\"></script>\n<script src='assets/js/plotly-2.8.3.min.js'></script>\n\n# Overview\n\nFrom the [Shiny website](https://shiny.rstudio.com/):\n\n> Shiny is an R package that makes it easy to build interactive web apps straight from R. You can host standalone apps on a webpage or embed them in R Markdown documents or build dashboards. You can also extend your Shiny apps with CSS themes, htmlwidgets, and JavaScript actions.\n\nShiny is a wonderful tool, providing a low-entry option for R programmers to develop single-page web applications.  But, _in my opinion_, it is over-used, and often pushed a fair bit beyond its ideal use-case.  In this post, we consider where Shiny might be a good option, and where it might not.  And even when Shiny is a good option, there are still some common patterns which might be better served by alternative approaches.\n\n(Note that the source code for all the apps and services in this post can be downloaded from [cmhh/too-much-shiny](https://github.com/cmhh/too-much-shiny).)\n\n# Shiny in Practice?\n\nFundamentally, Shiny applications run on a remote server, with a persistent communication channel being established between the client and the remote server, typically a WebSocket.  An obvious alternative is to create an application that runs in the client's browser, with no such requirement for a _persistent_ connection to any such server.  The two approaches each have their own strengths and weaknesses, and there are certainly situations where Shiny is a sensible solution.\n\nFirstly, data might well be too large to be bundled in a client-side application.  A common solution is to bundle data with a Shiny application&ndash;clients then make selections which are actioned on the remote computer, and only small slices are sent to the client at any one time.  This works well enough, but has a few drawbacks, the main one being that applications need to be redeployed whenever the underlying data is updated.  An alternative, though, is to create a data service which the application can call.  New data can be deployed, then, without interruption to the published application, and in this case it might also become plausible to deploy the application as a client-side application, with no remote dependencies other than the data service itself.  Of course, we really are only shifting the problem since we still need to host our data service, and to establish a process for updating the underlying data, and this may or may not be easier in practice than bundling data with a Shiny application.\n\nAnother common reason for using Shiny might well be because functionality required by an application already exists in R, and we simply don't have the time or will to re-implement the logic ourselves elsewhere.  The methods being used might also be computationally expensive, and we'd rather the computational burden be lumped with us, rather than users of the application.  Just as one possible solution to the data-bundling problem might be to develop a remote data service, there are a number of remote execution options for R in practice.  That is, rather than write a Shiny application to make use of some R function, we make that R function available as a remote procedure call which can be used from a client-side application developed in some other way.  (Actually, one nice thing about remote procedure calls is that they can be utilised by _any_ client that has basic HTTP capabilities such as GET and POST).  \n\nFinally, Shiny might just be used for purely practical or pragmatic reasons.  For developers who are already familiar with R, Shiny is _comically_ easy, and functional applications can be created _extremely_ rapidly, often with relatively little coding effort.  Moreover, in some organisations, options are limited to some approved, possibly very narrow set.  It might well be that there is an existing approved process or pipeline for publishing Shiny applications, and it might simply be easier to leverage the existing process than to gain approval to use something else.  The difficulty of the latter shouldn't be underestimated, and you should count yourself lucky if it isn't a problem for you!  Shiny supports HTML templates, though, and so non-Shiny applications can be published as 'Shiny' applications in a pinch (a hack to be sure, and one that your particular I.T. department might not look very fondly on).\n\nWe will explore all of these scenarios, among others, with illustrative examples.  The general approach will be to take an existing Shiny application, and rewrite it as a client-side application using [Vue.js](https://vuejs.org/).  Where the replacement applications require support in the way of a data service or remote procedure call, we will use [Plumber](https://www.rplumber.io/).  Plumber is a tool that lets us create server-side APIs simply by annotating existing R functions&ndash;we could use any number of alternatives, Node, for example, but using Plumber will have the happy secondary benefit of being easy to understand for R users.\n\n# Vue.js\n\nVue.js is a progressive JavaScript framework used for creating reactive web applications.  By this we mean that it is possible to adopt Vue incrementally, using as little, or as much, as needed.  To illustrate, here is a complete Vue application, embedded right here in this page:\n\n<div id=\"counterapp1\">\n<button @click=\"count--\">-</button> \n<p v-bind:style=\"counterStyle\"> {{ this.count }} </p> \n<button @click=\"count++\">+</button>\n</div>\n<script>\nconst counterApp1 = new Vue({\n  el: \"#counterapp1\",\n  data: {\n    count: 0,\n    counterStyle: {display: \"inline-block\", width: \"30px\", textAlign: \"center\"}\n  }\n})\n</script>\n\nThe code that produced the application can be pasted into any HTML page, and looks as follows:\n\n```html\n<div id=\"counterapp1\">\n<button @click=\"count--\">-</button> \n<p v-bind:style=\"counterStyle\"> {{ this.count }} </p> \n<button @click=\"count++\">+</button>\n</div>\n<script>\nconst counterApp1 = new Vue({\n  el: \"#counterapp1\",\n  data: {\n    count: 0,\n    counterStyle: {display: \"inline-block\", width: \"30px\", textAlign: \"center\"}\n  }\n})\n</script>\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"></script>\n```\n\nOne particularly powerful feature of Vue is the ability to encapsulate controls and other elements as so-called Vue components.  Components can be shipped as a library and re-used.  For example, in the simple example above we had a simple counter with increment and decrement buttons.  We can make a counter component as follows:\n\n```html\n<script>\nVue.component('vue-counter', {\n  data: function() {\n    return {\n      count: 0,\n      counterStyle: {display: \"inline-block\", width: \"30px\", textAlign: \"center\"}\n    }\n  },\n  template: `\n  <div><button @click=\"count--\">-</button> \n  <p v-bind:style=\"counterStyle\"> {{ this.count }} </p> \n  <button @click=\"count++\">+</button></div>\n  `\n});\n</script>\n```\n\nWe can then reproduce the example application using the controller instead as follows:\n\n```html\n<div id=\"counterapp1\">\n<vue-counter></vue-counter>\n</div>\n\n<script>\nconst counterApp1 = new Vue({ el: \"#counterapp1\" })\n</script>\n```\n\nWhile a little more work overall than the original example, the effort really pays off if we have the need for several controllers&ndash;perhaps in different applications.  For example the following code:\n\n```html\n<div id=\"counterapp2\">\n<vue-counter></vue-counter>\n<vue-counter></vue-counter>\n<vue-counter></vue-counter>\n</div>\n\n<script>\nconst counterApp2 = new Vue({ el: \"#counterapp2\" })\n</script>\n```\n\nproduces:\n\n<div id=\"counterapp2\">\n<vue-counter></vue-counter>\n<vue-counter></vue-counter>\n<vue-counter></vue-counter>\n</div>\n\n<script>\nVue.component('vue-counter', {\n  data: function() {\n    return {\n      count: 0,\n      counterStyle: {display: \"inline-block\", width: \"30px\", textAlign: \"center\"}\n    }\n  },\n  template: `\n  <div><button @click=\"count--\">-</button> \n  <p v-bind:style=\"counterStyle\"> {{ this.count }} </p> \n  <button @click=\"count++\">+</button></div>\n  `\n});\n\nconst counterApp2 = new Vue({ el: \"#counterapp2\" })\n</script>\n\nWe won't make much (any) use of components in this post, but it is an important feature to be aware of.  In the examples in this post, Shiny applications will usually require less user-written code than the equivalent Vue application.  This is because Shiny provides a high-level interface over top of existing JavaScript libraries and CSS frameworks (mostly [Bootstrap](https://getbootstrap.com/)), and the same thing is, of course, possible with Vue in practice simply by finding the appropriate component libraries online, or rolling your own if later re-use can justify the effort.\n\n# Plumber\n\nFrom [the Plumber website](https://www.rplumber.io/):\n\n> Plumber allows you to create a web API by merely decorating your existing R source code with roxygen2-like comments.\n\nFor example, say we had the following very simple R function:\n\n```r\nfunction(n) runif(n)\n```\n\nWe could annotate this function in a script in the following way:\n\n:::{.panel-tabset}\n\n## `rand.R`\n\n```r\n#* Get a sequence of random numbers\n#* @param n Size of sequence\n#* @get /rand\nfunction(n) runif(n)\n```\n\n:::\n\nGiven this script, we can then start this as a service simply by running:\n\n```r\nlibrary(plumber)\npr(file = \"rand.R\") |> pr_run(port = 3000)\n```\n\nWe can then GET this in an obvious way:\n\n```bash\ncurl -sX GET \"http://127.0.0.1:3000/rand?n=10\" -H \"accept: */*\" | jq\n```\n```json\n[\n  0.1999,\n  0.651,\n  0.8456,\n  0.089,\n  0.3904,\n  0.4123,\n  0.5724,\n  0.9378,\n  0.7262,\n  0.9282\n]\n```\n\nAs noted, there are many options for deploying services, and Plumber is used here mostly for illustrative purposes.  That said, where we are interested in functionality that exists within R, perhaps even exclusively so, then Plumber provides an easy way to make that functionality available to users of other languages, and to client-side applications in particular.\n\n# A Simple Example with Bundled Data\n\nWhen we run `shiny::runExample(\"01_hello\", display.mode = \"normal\")`, we are met with with the following:\n\n![](assets/img/01hello.webp)\n\nThe source code for the entire app is _very_ simple (slightly modified to read the data from an external file, rather than use a dataset that is bundled with R):\n\n:::{.panel-tabset}\n\n## `app.R`\n\n```r\nlibrary(shiny)\n\nfaithful <- readRDS(\"data/faithful.rds\")\n\nui <- fluidPage(\n  titlePanel(\"Hello Shiny!\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\n        inputId = \"bins\",\n        label = \"Number of bins:\",\n        min = 1, max = 50, value = 30\n      )\n    ),\n    mainPanel(\n      plotOutput(outputId = \"distPlot\")\n    )\n  )\n)\n\nserver <- function(input, output) {\n  output$distPlot <- renderPlot({\n    x <- faithful$waiting\n    bins <- seq(min(x), max(x), length.out = input$bins + 1)\n    hist(\n      x, breaks = bins, col = \"#75AADB\", border = \"white\",\n      xlab = \"Waiting time to next eruption (in mins)\",\n      main = \"Histogram of waiting times\")\n    })\n}\n\nshinyApp(ui = ui, server = server)\n```\n\n:::\n\nFor contrast, here is the complete source for a similar application created with Vue.js:\n\n:::{.panel-tabset}\n\n## `index.html`\n\n```html\n<html>\n<head>\n  <title>Hello Vue.js!</title>\n  <link href=\"https://cdn.jsdelivr.net/npm/@mdi/font@6.x/css/materialdesignicons.min.css\" rel=\"stylesheet\">\n  <link href=\"https://cdn.jsdelivr.net/npm/vue-slider-component@latest/theme/default.css\" rel=\"stylesheet\">\n  <link href=\"./styles.css\" rel=\"stylesheet\"/>\n</head>\n\n<body>\n<div id=faithfulapp>\n  <div class=\"title\"><h1>Hello Vue.js!</h1></div>\n  <div class=\"body\">\n    <div class=\"slidercontainer\">\n        <vue-slider\n          v-model=\"bins\" :min=\"1\" :max=\"50\" :tooltip=\"'always'\"\n          :marks=\"[1,5,10,15,20,25,30,35,40,45,50]\"\n        ></vue-slider>\n    </div>\n    <div class=\"plotcontainer\">\n      <div id=\"plot\"></div>\n    </div>\n  </div>\n  <p>blah</p>\n</div>\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/vue-slider-component@latest/dist/vue-slider-component.umd.min.js\"></script>\n<script src='https://cdn.plot.ly/plotly-2.8.3.min.js'></script>\n<script src=\"./faithful.js\"></script>\n<script src='./main.js'></script>\n</body>\n</html>\n```\n\n## `main.js`\n\n```js\nvar faithfulapp = new Vue({\n  el: '#faithfulapp',\n  data: {\n    data: faithful,\n    layout: {\n      title: \"histogram of waiting times\",\n      xaxis: {title: {text: \"waiting time to next eruption (in mins)\"}},\n      yaxis: {title: {text: \"Frequency\"}}},\n    config: { responsive: true },\n    bins: 30\n  },\n  computed: {\n    series: function() {\n      return [{\n        x: this.data,\n        type: 'histogram',\n        nbinsx: this.bins\n      }];\n    }\n  },\n  watch: {\n    series: function() {\n      this.updatePlot()\n    }\n  },\n  mounted: function() {\n    this.updatePlot()\n  },\n  methods: {\n    updatePlot: function() {\n      Plotly.newPlot('plot', this.series, this.layout, this.config)\n    }\n  },\n  components: {\n    'vueSlider': window[ 'vue-slider-component' ],\n  }\n});\n```\n\n## `faithful.js`\n\n```js\nwindow.faithful = (function() {\n  return [\n    79,54,74,62,85,55,88,85,51,85,54,84,78,47,83,52,62,84,52,79,51,47,78,69,74,\n    83,55,76,78,79,73,77,66,80,74,52,48,80,59,90,80,58,84,58,73,83,64,53,82,59,\n    75,90,54,80,54,83,71,64,77,81,59,84,48,82,60,92,78,78,65,73,82,56,79,71,62,\n    76,60,78,76,83,75,82,70,65,73,88,76,80,48,86,60,90,50,78,63,72,84,75,51,82,\n    62,88,49,83,81,47,84,52,86,81,75,59,89,79,59,81,50,85,59,87,53,69,77,56,88,\n    81,45,82,55,90,45,83,56,89,46,82,51,86,53,79,81,60,82,77,76,59,80,49,96,53,\n    77,77,65,81,71,70,81,93,53,89,45,86,58,78,66,76,63,88,52,93,49,57,77,68,81,\n    81,73,50,85,74,55,77,83,83,51,78,84,46,83,55,81,57,76,84,77,81,87,77,51,78,\n    60,82,91,53,78,46,77,84,49,83,71,80,49,75,64,76,53,94,55,76,50,82,54,75,78,\n    79,78,78,70,79,70,54,86,50,90,54,54,77,79,64,75,47,86,63,85,82,57,82,67,74,\n    54,83,73,73,88,80,71,83,56,79,78,84,58,83,43,60,75,81,46,90,46,74\n  ];\n})();\n```\n\n## `styles.css`\n\n```css\n@import url('https://fonts.googleapis.com/css2?family=Open+Sans&display=swap');\n\n#faithfulapp * {\n  font-family: \"Open Sans\", verdana, arial, sans-serif;\n}\n\n#faithfulapp p {\n  margin: 0;\n}\n\n#faithfulapp  .body {\n  display: block;\n  width: 100%;\n}\n\n#faithfulapp .title h1 {\n  font-size: 30px;\n  font-weight: 500;\n  margin-bottom: 10px;\n}\n\n#faithfulapp .slidercontainer {\n  display: inline-block;\n  width: calc(30% - 32px);\n  overflow: none;\n  vertical-align: top;\n  border: 1px solid #999;\n  border-radius: 5px;\n  background-color: #eee;\n  padding: 35px 15px 25px 15px;\n}\n\n#faithfulapp .plotcontainer {\n  display: inline-block;\n  width: 70%;\n}\n```\n\n:::\n\nBecause the Vue application is a pure client-side application, we can embed it directly here, whereas the Shiny app must be hosted on a remote server.  The Vue application looks as follows:\n\n<link rel=\"stylesheet\" href=\"./assets/css/01_hello.css\" />\n\n\n```{html}\n<div id=faithfulappx>\n  <div><h1>Hello Vue.js!</h1></div>\n  <div>\n    <div>\n        <p>blah</p>\n    </div>\n    <div>\n      <div id=\"plots\"></div>\n    </div>\n  </div>\n</div>\n```\n\n\n<div id=faithfulapp>\n  <div class=\"title\"><h1>Hello Vue.js!</h1></div>\n  <div class=\"body\">\n    <div class=\"slidercontainer\">\n        <vue-slider\n          v-model=\"bins\" :min=\"1\" :max=\"50\" :tooltip=\"'always'\"\n          :marks=\"[1,10,20,30,40,50]\"\n        ></vue-slider>\n    </div>\n    <div class=\"plotcontainer\">\n      <div id=\"plot\"></div>\n    </div>\n  </div>\n</div>\n\n<script src=\"./assets/js/vue-slider-component.umd.min.js\"></script>\n<script src=\"./assets/js/faithful.js\"></script>\n<script src='./assets/js/01_hello.js'></script>\n\nThe Shiny application is undeniably simpler from a developer perspective, at least in terms of the volume of code.  This is largely because we are using a pre-canned template, with pre-canned user widgets, and default styling which we have not modified.  Things escalate quickly if any of these things are not true.  For example, if we want a more bespoke layout, custom styling, or non-standard widgets.  Running Shiny applications are made up largely of HTML and JavaScript after all.\n\n\n# A Less Simple Example with Bundled Data\n\nIn this example we start with a Shiny application that has a relatively large data asset bundled along with the application source&ndash;a data frame containing 1,118,488 rows, occupying 125.4MB in-memory, and 3.2MB compressed to disk (or 244.1MB saved as a CSV, and 6.6MB as a gzipped CSV).  We will then make the same data available via a remote data service.  We then modify the Shiny application so it uses the service, and remove all trace of the bundled data.  Finally, we port the Shiny application using Vue.js.\n\n## Shiny with Bundled Data\n\nThe complete source for our first attempt is relatively simple, and looks as follows:\n\n<div class=\"tabs-with-content\" id=\"labour_market_1\">\n<div class=\"tabs is-boxed\">\n<ul>\n  <li class=\"is-active\"><a>ui.R</a></li>\n  <li><a>server.R</a></li>\n  <li><a>global.R</a></li>\n</ul>\n</div>\n<div>\n<section class=\"tab-content\">\n\n```r\nshinyUI(fluidPage(\n  titlePanel(\"Labour Market Time Series Data\"),\n\n  sidebarLayout(\n    sidebarPanel(width = 4,\n      selectizeInput(\n        \"subject\", \"select subject:\", subject_choices\n      ),\n      selectizeInput(\n        \"group\", \"select group:\", c()\n      ),\n      selectizeInput(\n        \"series\", \"select series:\", c(), multiple = TRUE\n      )\n    ),\n\n    mainPanel(width = 8,\n      plotlyOutput(\"plot\")\n    )\n  )\n))\n```\n\n</section>\n<section class=\"tab-content\">\n\n```r\nshinyServer(function(input, output, session) {\n  groups <- reactive({\n    req(input$subject)\n    unique(data[\n      subject_code == input$subject,\n      .(group_code, group_description)\n    ])\n  })\n\n  series <- reactive({\n    req(input$subject, input$group)\n    unique(data[\n      subject_code == input$subject & group_code == input$group,\n      c(\"series_reference\", sprintf(\"series_title_%d\", 1:5)),\n      with = FALSE\n    ])\n  })\n\n  values <- reactive({\n    req(input$subject, input$group, input$series)\n\n    data[\n      subject_code == input$subject & group_code == input$group &\n        series_reference %in% input$series\n    ]\n  })\n\n  observeEvent(groups(), {\n    group_choices <- setNames(\n      groups()$group_code,\n      groups()$group_description\n    )\n\n    updateSelectizeInput(session, \"group\", choices = group_choices)\n  })\n\n  observeEvent(series(), {\n    labels <- apply(series(), 1, function(z) {\n      z[-1] |> (\\(x) {x[x != \"\"]})() |> paste(collapse = \", \")\n    })\n\n    subject_choices <- setNames(\n      series()$series_reference,\n      sprintf(\"%s - %s\", series()$series_reference, labels)\n    )\n\n    updateSelectizeInput(session, \"series\", choices = subject_choices)\n  })\n\n  output$plot <- renderPlotly({\n    req(values())\n    if (is.null(values())) return(NULL)\n    if (nrow(values()) == 0) return(NULL)\n\n    p <- ggplot(\n      data = values(),\n      aes(x = period, y = data_value, col = series_reference)\n    ) +\n      geom_line()\n\n    ggplotly(p)\n  })\n})\n```\n\n</section>\n<section class=\"tab-content\">\n\n```r\nlibrary(shiny)\nlibrary(data.table)\nlibrary(ggplot2)\nlibrary(plotly)\n\ndata <- readRDS(\"../../data/labour_market.rds\")\n\nsubjects <- unique(data[, .(subject_code, subject_description)])\n\nsubject_choices <- setNames(\n  subjects$subject_code,\n  sprintf(\"%s - %s\", subjects$subject_code, subjects$subject_description)\n)\n```\n\n</section>\n</div>\n</div>\n\nand the running application looks as follows:\n\n<a href=\"assets/img/labour_market_1.webp\" target=\"_blank\">\n<img src=\"assets/img/labour_market_1.webp\" class=\"Large\"/></a>\n\n## Creating a Supporting Data Service\n\nAs described, the first cut of our Shiny application has bundled with it a large data frame, but we are only ever interested in a small subset at any point in time.  The subset we are interested in is determined by client selections, and the filtered data is made available via a reactive expression.  For example, in our application, users can select a subject, then a group, and then up to `$n$` series references, and we then use the selected values to filter the bundled data:\n\n```r\nvalues <- reactive({\n  req(input$subject, input$group, input$series)\n\n  data[\n    subject_code == input$subject & group_code == input$group &\n      series_reference %in% input$series\n  ]\n})\n```\n\nThat is, calling `values()` in our code will always return the correct subset, and any reactive block of code that depends on it will be re-evaluated whenever the underlying inputs change.  Here we plot the result using standard plotting functions, thus separating the logic for deciding _what_ we plot and _how_ we plot.  This is a reasonable practice in Shiny&ndash;that we access data via reactive expressions where possible&ndash;keeping such concerns separate from other logic, and helping keep our applications modular.  But if we follow such a practice when authoring Shiny applications, we then have a reasonably obvious path for replacing the bundled data with a service&ndash;we simply create a service with end-points that roughly match our reactive expressions.  Thus, the only changes we would need to make to our existing application would be to each of the reactive expressions which access the original bundled data.  In this case, a sufficient service is fully described as follows:\n\n<div class=\"tabs-with-content\" id=\"labour_market_service\">\n<div class=\"tabs is-boxed\">\n<ul>\n  <li class=\"is-active\"><a>labour_market_service.R</a></li>\n  <li class=\"is-active\"><a>run_labour_market_service.R</a></li>\n</ul>\n</div>\n<div>\n<section class=\"tab-content\">\n\n```r\n#* @apiTitle Labour market data service\n#* @apiDescription Data service for HLFS, QES, and LCI time series data.\n\nlibrary(data.table)\ndata <- readRDS(\"../data/labour_market.rds\")\nsubjects <- unique(data[, c(\"subject_code\", \"subject_description\")])\n\n#* @filter cors\n#* turn this off in production!!\ncors <- function(res) {\n    res$setHeader(\"Access-Control-Allow-Origin\", \"*\")\n    plumber::forward()\n}\n\n#* Return complete set of subjects\n#* @get /subjects\n#* @serializer json\nfunction() {\n  subjects\n}\n\n#* Return complete set of groups for selected subject\n#* @get /groups/<subjectCode>\n#* @serializer json\nfunction(subjectCode) {\n  unique(data[\n    subject_code == subjectCode,\n    c(\"subject_code\", \"group_code\", \"group_description\")\n  ])\n}\n\n#* Return complete set of series references for selected subject and group\n#* @get /series/<subjectCode>/<groupCode>\n#* @serializer json\nfunction(subjectCode, groupCode) {\n  unique(data[\n    subject_code == subjectCode & group_code == groupCode,\n    c(\"subject_code\", \"group_code\", \"group_description\",\n      \"series_reference\", \"units\", \"magnitude\",\n      sprintf(\"series_title_%d\", 1:5)), with = FALSE\n  ])\n}\n\n#* Return data for specific references\n#* @param seriesReference:[string] Series reference, e.g. \"HLFQ.SAA1AZ\"\n#* @get /values\n#* @serializer json\nfunction(seriesReference) {\n  data[series_reference %in% seriesReference]\n}\n\n#* Return data for specific references\n#* @param seriesReference:[string] Series reference, e.g. \"HLFQ.SAA1AZ\"\n#* @get /values/<subjectCode>/<groupCode>\n#* @serializer json\nfunction(subjectCode, groupCode, seriesReference) {\n  data[\n    subject_code == subjectCode & group_code == groupCode &\n      series_reference %in% seriesReference\n  ]\n}\n```\n\n</section>\n<section class=\"tab-content\">\n\n```r\nlibrary(plumber)\npr(\"labour_market_service.R\") |> pr_run(host = \"0.0.0.0\", port = 3001)\n```\n\n</section>\n</div>\n</div>\n\nAs an aside, the performance of this service is actually surprisingly good.  This is essentially because we've used the [`data.table`](https://rdatatable.gitlab.io/data.table/) package which is _extremely_ fast.  As an example, here is the result of fetching a single series using  [`siege`](https://github.com/JoeDog/siege) \n\n```bash\nsiege -b -c 3 -t 10s \"http://localhost:3001/series?seriesReference=HLFQ.SAA1AZ\"\n```\n```plaintext\n** SIEGE 4.0.7\n** Preparing 3 concurrent users for battle.\nThe server is now under siege...\nLifting the server siege...\nTransactions:                   6216 hits\nAvailability:                 100.00 %\nElapsed time:                   9.12 secs\nData transferred:               0.33 MB\nResponse time:                  0.00 secs\nTransaction rate:             681.58 trans/sec\nThroughput:                     0.04 MB/sec\nConcurrency:                    2.98\nSuccessful transactions:           0\nFailed transactions:               0\nLongest transaction:            0.06\nShortest transaction:           0.00\n```\n\n(Note that performance slowed if the number of concurrent workers exceeded 3.  This is possibly because my machine has just 6 cores / 12 threads, and `data.table` was using 6 threads by default already.  In saying that, CPU utilisation appeared low while the test was running.)\n\n## Shiny with a Data Service (and No Bundled Data)\n\nGiven an available service, we can easily modify our application, removing all dependencies on the bundled data.  Before listing the complete source, however, we lift out a single reactive expression for illustration&ndash;`series`, in this case:\n\n<div class=\"tabs-with-content\" id=\"reactive_ex\">\n<div class=\"tabs is-boxed\">\n<ul>\n  <li><a>old</a></li>\n  <li class=\"is-active\"><a>new</a></li>\n</ul>\n</div>\n<div>\n<section class=\"tab-content\">\n\n```r\nseries <- reactive({\n  req(input$subject, input$group)\n  unique(data[\n    subject_code == input$subject & group_code == input$group,\n    c(\"series_reference\", sprintf(\"series_title_%d\", 1:5)),\n    with = FALSE\n  ])\n})\n```\n\n</section>\n<section class=\"tab-content\">\n\n```r\nseries <- reactive({\n  req(input$subject, input$group)\n  url <- sprintf(\"%s/series/%s/%s\", service, input$subject, input$group)\n  response <- setDT(jsonlite::fromJSON(url))\n\n  if (length(response) == 0) return(NULL)\n\n  response[\n    ,c(\"series_reference\", sprintf(\"series_title_%d\", 1:5)),\n    with = FALSE\n  ]\n})\n```\n\n</section>\n</div>\n</div>\n\nAgain, our application is mostly unchanged besides these reactive expressions (we remove the data dependency in `global.R`, and replace it with the path to our service).  The full source is as follows:\n\n<div class=\"tabs-with-content\" id=\"labour_market_2\">\n<div class=\"tabs is-boxed\">\n<ul>\n  <li class=\"is-active\"><a>ui.R</a></li>\n  <li><a>server.R</a></li>\n  <li><a>global.R</a></li>\n  <li><a>config.yml</a></li>\n</ul>\n</div>\n<div>\n<section class=\"tab-content\">\n\n```r\nshinyUI(fluidPage(\n  titlePanel(\"Labour Market Time Series Data\"),\n\n  sidebarLayout(\n    sidebarPanel(width = 4,\n      selectizeInput(\n        \"subject\", \"select subject:\", subject_choices\n      ),\n      selectizeInput(\n        \"group\", \"select group:\", c()\n      ),\n      selectizeInput(\n        \"series\", \"select series:\", c(), multiple = TRUE\n      )\n    ),\n\n    mainPanel(width = 8,\n      plotlyOutput(\"plot\")\n    )\n  )\n))\n```\n\n</section>\n<section class=\"tab-content\">\n\n```r\nshinyServer(function(input, output, session) {\n  groups <- reactive({\n    req(input$subject)\n    url <- sprintf(\"%s/groups/%s\", service, input$subject)\n    setDT(jsonlite::fromJSON(url))\n  })\n\n  series <- reactive({\n    req(input$subject, input$group)\n    url <- sprintf(\"%s/series/%s/%s\", service, input$subject, input$group)\n    response <- setDT(jsonlite::fromJSON(url))\n\n    if (length(response) == 0) return(NULL)\n\n    response[\n      ,c(\"series_reference\", sprintf(\"series_title_%d\", 1:5)),\n      with = FALSE\n    ]\n  })\n\n  values <- reactive({\n    req(input$subject, input$group, input$series)\n\n    url <- sprintf(\n      \"%s/values/%s/%s?%s\",\n      service,\n      input$subject,\n      input$group,\n      paste(sprintf(\"seriesReference=%s\", input$series), collapse = \"&\")\n    )\n\n    response <- setDT(jsonlite::fromJSON(url))\n\n    if (length(response) == 0)\n      return(NULL)\n    else\n      response[, period := as.Date(period, format = \"%Y-%m-%d\")]\n  })\n\n  observeEvent(groups(), {\n    group_choices <- setNames(\n      groups()$group_code,\n      groups()$group_description\n    )\n\n    updateSelectizeInput(session, \"group\", choices = group_choices)\n  })\n\n  observeEvent(series(), {\n    labels <- apply(series(), 1, function(z) {\n      z[-1] |> (\\(x) {x[x != \"\"]})() |> paste(collapse = \", \")\n    })\n\n    subject_choices <- setNames(\n      series()$series_reference,\n      sprintf(\"%s - %s\", series()$series_reference, labels)\n    )\n\n    updateSelectizeInput(session, \"series\", choices = subject_choices)\n  })\n\n  output$plot <- renderPlotly({\n    req(values())\n    if (is.null(values())) return(NULL)\n    if (nrow(values()) == 0) return(NULL)\n\n    p <- ggplot(\n      data = values(),\n      aes(x = period, y = data_value, col = series_reference)\n    ) +\n      geom_line()\n\n    ggplotly(p)\n  })\n})\n```\n\n</section>\n<section class=\"tab-content\">\n\n```r\nlibrary(shiny)\nlibrary(data.table)\nlibrary(ggplot2)\nlibrary(plotly)\nlibrary(config)\n\nservice <- config::get(\"service\")\n\nsubjects <- jsonlite::fromJSON(sprintf(\"%s/subjects\", service))\n\nsubject_choices <- setNames(\n  subjects$subject_code,\n  sprintf(\"%s - %s\", subjects$subject_code, subjects$subject_description)\n)\n```\n\n</section>\n<section class=\"tab-content\">\n\n```yml\ndefault:\n  service: \"http://localhost:3001\"\n```\n\n</section>\n</div>\n</div>\n\nAnd note our application starts up a little faster now since we do not have to wait for the bundled data to be read into memory.  And, as noted in the overview, we have disentangled our application and the data completely, and so we can update our data service without needing to modify our application or redeploy it.  Cool.\n\n## Vue.js Application with a Data Service\n\nFollowing the trend, the source code for a client-side Vue application is longer and more verbose than the Shiny code, but not unmanageably so.  The complete code is:\n\n<div class=\"tabs-with-content\" id=\"labour_market_3\">\n<div class=\"tabs is-boxed\">\n<ul>\n  <li class=\"is-active\"><a>index.html</a></li>\n  <li><a>main.js</a></li>\n  <li><a>styles.css</a></li>\n</ul>\n</div>\n<div>\n<section class=\"tab-content\">\n\n```html\n<html>\n<head>\n  <title>Labour Market Time Series Data</title>\n  <link rel=\"stylesheet\" href=\"https://unpkg.com/vue-select@3.0.0/dist/vue-select.css\">\n  <link rel=\"stylesheet\" href=\"./styles.css\" />\n</head>\n\n<body>\n<div id=labmktapp>\n  <div class=\"title\"><h1>Labour Market Time Series Data</h1></div>\n  <div class=\"body\">\n    <div class=\"controls\">\n      <p class=\"label\">select subject:</p>\n      <v-select v-model=\"selectedSubject\" :options=\"subjects\" id=\"subject-select\"></v-select>\n\n      <p class=\"label\">select group:</p>\n      <v-select v-model=\"selectedGroup\" :options=\"groups\" id=\"group-select\"></v-select>\n\n      <p class=\"label\">select series:</p>\n      <v-select v-model=\"selectedSeries\" :options=\"series\" id=\"series-select\" multiple></v-select>\n      </select>\n    </div>\n    <div class=\"plotcontainer\">\n      <div id=\"labmktplot\"></div>\n    </div>\n  </div>\n</div>\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"></script>\n<script src=\"https://unpkg.com/vue-select@3.0.0\"></script>\n<script src=\"https://unpkg.com/axios/dist/axios.min.js\"></script>\n<script src='https://cdn.plot.ly/plotly-2.8.3.min.js'></script>\n<script src='./main.js'></script>\n\n</body>\n</html>\n```\n\n</section>\n\n<section class=\"tab-content\">\n\n```js\nconst server = \"http://localhost:3001\";\n\nVue.component('v-select', VueSelect.VueSelect);\nvar app = new Vue({\n  el: \"#labmktapp\",\n  data: {\n    subjects: [],\n    selectedSubject: {},\n    groups: [],\n    selectedGroup: {},\n    series: [],\n    selectedSeries: [],\n    values: [],\n    layout: {\n      xaxis: {title: {text: \"date\"}},\n      legend: {orientation: \"h\", yanchor: \"bottom\", y: -0.25},\n      margin: {t: 0}\n    },\n    config: { responsive: true }\n  },\n  mounted: function() {\n    const self = this\n    axios\n      .get(`${server}/subjects`)\n      .then(function (response) {\n        self.subjects = response.data.map(x => {\n          let obj = {}\n          obj[\"code\"] = x.subject_code\n          obj[\"label\"] = `${x.subject_code} - ${x.subject_description}`\n          return obj\n        })\n        self.selectedSubject = self.subjects[0]\n        self.selectedGroup = {}\n        self.selectedSeries = []\n      })\n      .catch(function (error) {\n        console.log(error)\n      })\n  },\n  computed: {\n    trace: function() {\n      const refs = this.values\n        .map(x => {return x.series_reference})\n        .filter((v,i,a) => a.indexOf(v) == i)\n\n      res = refs.map(ref => {\n        const sub = this.values.filter(x => x.series_reference == ref)\n        const xs = sub.map(x => {return x.period})\n        const ys = sub.map(x => {return x.data_value})\n        obj = {}\n        obj[\"type\"] = \"scatter\"\n        obj[\"mode\"] = \"lines\"\n        obj[\"name\"] = ref\n        obj[\"x\"] = xs\n        obj[\"y\"] = ys\n        return obj\n      })\n\n      return res\n    }\n  },\n  watch: {\n    selectedSubject: function() {\n      const self = this\n      const url = `${server}/groups/${self.selectedSubject[\"code\"]}`\n      axios\n        .get(url)\n        .then(function(response) {\n          data = response.data.map(x => {\n            obj = {}\n            obj[\"code\"] = x.group_code\n            obj[\"label\"] = x.group_description\n            return obj\n          })\n          self.groups = data\n          self.selectedGroup = data[0]\n        })\n        .catch(function (error) {\n          console.log(error)\n        })\n    },\n    selectedGroup: function() {\n      const self = this\n      axios\n        .get(`${server}/series/${self.selectedSubject[\"code\"]}/${self.selectedGroup[\"code\"]}`)\n        .then(function (response) {\n          self.series = response.data.map(x => {\n            obj = {}\n            obj[\"code\"] = x.series_reference\n            obj[\"label\"] = x.series_reference + \" - \" + self.titles(x)\n            return obj\n          })\n          self.selectedSeries = []\n        })\n        .catch(function (error) {\n          console.log(error)\n        })\n    },\n    selectedSeries: function() {\n      const self = this\n      if (self.selectedSeries.length == 0) {\n        self.values = []\n      } else {\n        const refQuery = self.selectedSeries.map(x => {\n          return `seriesReference=${x.code}`\n        }).join('&')\n\n        const url = `${server}/values/${self.selectedSubject[\"code\"]}/` +\n          `${self.selectedGroup[\"code\"]}?${refQuery}`\n\n        axios\n          .get(url)\n          .then(function(response) {\n            self.values = response.data\n          })\n          .catch(function (error) {\n            console.log(error)\n          })\n      }\n    },\n    trace: function() {\n      if (this.trace.length == 0) {\n        this.hidePlot()\n      } else {\n        this.unhidePlot()\n      }\n      this.updatePlot()\n    }\n  },\n  methods: {\n    titles: function(s) {\n      var res = s.series_title_1\n      if (s.series_title_2 != \"\") res = res + \", \" + s.series_title_2\n      if (s.series_title_3 != \"\") res = res + \", \" + s.series_title_3\n      if (s.series_title_4 != \"\") res = res + \", \" + s.series_title_4\n      if (s.series_title_5 != \"\") res = res + \", \" + s.series_title_5\n      return res\n    },\n    hidePlot: function() {\n      document.getElementById(\"labmktplot\").style.display = \"none\"\n    },\n    unhidePlot: function() {\n      document.getElementById(\"labmktplot\").style.display = \"block\"\n    },\n    updatePlot: function() {\n      Plotly.newPlot('labmktplot', this.trace, this.layout, this.config)\n    }\n  }\n})\n```\n\n</section>\n\n<section class=\"tab-content\">\n\n```css\n@import url('https://fonts.googleapis.com/css2?family=Open+Sans&display=swap');\n\n#labmktapp * {\n  font-family: \"Open Sans\", verdana, arial, sans-serif;\n}\n\n#labmktapp {\n  width: 100%;\n}\n\n#labmktapp p {\n  margin: 0;\n}\n\n#labmktapp .title h1 {\n  font-size: 25px;\n  font-weight: 500;\n}\n\n#labmktapp .controls {\n  display: inline-block;\n  width: calc(40% - 30px);\n  vertical-align: top;\n  border: 1px solid #999;\n  border-radius: 5px;\n  background-color: #eee;\n  padding: 10px;\n}\n\n#labmktapp .plotcontainer {\n  display: inline-block;\n  width: 60%;\n}\n\n#labmktapp .v-select .vs__dropdown-toggle {\n  border-color: #999!important;\n  margin-bottom: 20px;\n}\n\n#labmktapp .v-select .vs__dropdown-toggle, #labmktapp .vs__dropdown-menu {\n  background: #FFF;\n  font-size: 80%;\n}\n\n#labmktapp p.label {\n  font-size: 80%;\n  font-weight: 700;\n  margin-bottom: 10px;\n}\n```\n\n</section>\n</div>\n</div>\n\nUnlike earlier examples, we cannot embed the Vue application directly here since it now depends on a data service which we have not deployed.  Either way, the resulting application looks as follows:\n\n<a href=\"assets/img/labour_market_3.webp\" target=\"_blank\">\n<img src=\"assets/img/labour_market_3.webp\" class=\"Large\"/></a>\n\n\n# Smuggling Non-Shiny Applications via HTML Templates\n\nGiven a working client-side application, all we need to do to run it via 'Shiny' is to place the full application in a folder called `www`, and create an application in the parent directory as follows:\n\n<div class=\"tabs-with-content\" id=\"labour_market_4\">\n<div class=\"tabs is-boxed\">\n<ul>\n  <li class=\"is-active\"><a>app.R</a></li>\n</ul>\n</div>\n<div>\n<section class=\"tab-content\">\n\n```r\nlibrary(shiny)\n\nshinyApp(\n  ui = htmlTemplate(\"www/index.html\"),\n  server = function(input, output, session){}\n)\n```\n\n</section>\n</div>\n</div>\n\nFor example, given the Vue application above, we have the following layout on disk:\n\n```bash\n$ tree .\n```\n```plaintext\n.\n├── app.R\n└── www\n    ├── index.html\n    ├── main.js\n    └── styles.css\n```\n\nand hey presto:\n\n<a href=\"assets/img/hello_vue_via_shiny.webp\" target=\"_blank\">\n<img src=\"assets/img/hello_vue_via_shiny.webp\" class=\"Large\"/></a>\n\n# Remote Procedure Calls\n\nThe very final example, and the weakest argument, perhaps, for a Shiny-alternative, is where a local application makes a remote procedure call.  That is, we have a Shiny application which could be written as a client-side application except that it needs to use functionality provided by R which we don't have readily available otherwise.  In this case, we can make the R functionality being used available as a remote procedure call, and use that in a client-side application instead.  This option is of dubious utility, and largely depends on the composition of the application.  For example, if the application is large and the amount of work that can only be done by R is small, then we have a reasonable case.  If the application is small, or the code-base is full of calls to R functions that would be hard to replace, then our case is very weak.\n\nEither way, consider the following very simple Shiny application, which is similar to the earlier 'Hello Shiny' / 'Hello Vue!', except that we replace the Faithful eruption data with a simple sequence of random uniform numbers:\n\n<div class=\"tabs-with-content\" id=\"hello-runif-shiny\">\n<div class=\"tabs is-boxed\">\n<ul>\n  <li class=\"is-active\"><a>app.R</a></li>\n</ul>\n</div>\n<div>\n<section class=\"tab-content\">\n\n```r\nlibrary(shiny)\n\nui <- fluidPage(\n  titlePanel(\"Hello runif from Shiny!\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\n        inputId = \"nobs\",\n        label = \"Number of observations:\",\n        min = 1, max = 10000, value = 1000\n      )\n    ),\n    mainPanel(\n      plotOutput(outputId = \"distPlot\")\n    )\n  )\n)\n\nserver <- function(input, output) {\n  data <- reactive({\n    runif(input$nobs)\n  })\n\n  output$distPlot <- renderPlot({\n    hist(\n      data(), col = \"#75AADB\", border = \"white\",\n      xlab = \"x\",\n      main = \"distribution of random uniform numbers\")\n    })\n}\n\nshinyApp(ui = ui, server = server)\n```\n\n</section>\n</div>\n</div>\n\nThe application looks as follows:\n\n<a href=\"assets/img/hello_runif_shiny.webp\" target=\"_blank\">\n<img src=\"assets/img/hello_runif_shiny.webp\" class=\"Large\"/></a>\n\nIn order to port the application to Vue, we first need to make the `runif` function available via a remote call, and this is precisely what we did above in the Plumber section.  The complete service is as follows:\n\n<div class=\"tabs-with-content\" id=\"rand_service\">\n<div class=\"tabs is-boxed\">\n<ul>\n  <li class=\"is-active\"><a>rand.R</a></li>\n  <li class=\"is-active\"><a>run_rand.R</a></li>\n</ul>\n</div>\n<div>\n<section class=\"tab-content\">\n\n```r\n#* @apiTitle Random uniform numbers\n#* @apiDescription Data service for generating sequences of random uniform numbers\n\n#* @filter cors\n#* turn this off in production!!\ncors <- function(res) {\n    res$setHeader(\"Access-Control-Allow-Origin\", \"*\")\n    plumber::forward()\n}\n\n#* Get a sequence of random numbers\n#* @param n Size of sequence\n#* @get /rand\nfunction(n) runif(n)\n```\n\n</section>\n<section class=\"tab-content\">\n\n```r\nlibrary(plumber)\npr(\"rand.R\") |> pr_run(host = \"0.0.0.0\", port = 3002)\n```\n\n</section>\n</div>\n</div>\n\nThe complete code listing for the Vue application is as follows:\n\n<div class=\"tabs-with-content\" id=\"hello-vue\">\n<div class=\"tabs is-boxed\">\n<ul>\n  <li class=\"is-active\"><a>index.html</a></li>\n  <li><a>main.js</a></li>\n  <li><a>styles.css</a></li>\n</ul>\n</div>\n<div>\n<section class=\"tab-content\">\n\n```html\n<html>\n<head>\n  <title>Hello runif!!</title>\n  <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/vue-slider-component@latest/theme/default.css\">\n  <link rel=\"stylesheet\" href=\"./styles.css\" />\n</head>\n\n<body>\n<div id=runifapp>\n  <div class=\"title\"><h1>Hello runif from Vue.js!</h1></div>\n  <div class=\"body\">\n    <div class=\"slidercontainer\">\n        <vue-slider\n          v-model=\"nobs\"\n          :min=\"1\"\n          :max=\"10000\"\n          :lazy=\"true\"\n          :marks=\"[1, 2000, 4000, 6000, 8000, 10000]\"\n          :tooltip=\"'always'\"\n        ></vue-slider>\n    </div>\n    <div class=\"plotcontainer\">\n      <div id=\"plot\"></div>\n    </div>\n  </div>\n</div>\n\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/vue-slider-component@latest/dist/vue-slider-component.umd.min.js\"></script>\n<script src=\"https://unpkg.com/axios/dist/axios.min.js\"></script>\n<script src='https://cdn.plot.ly/plotly-2.8.3.min.js'></script>\n<script src='./main.js'></script>\n\n</body>\n</html>\n```\n\n</section>\n\n<section class=\"tab-content\">\n\n```js\nconst server = \"http://localhost:3002\";\n\nvar faithfulapp = new Vue({\n  el: '#runifapp',\n  data: {\n    data: [],\n    layout: {\n      title: \"distribution of random uniform numbers\",\n      xaxis: {title: {text: \"x\"}}\n    },\n    config: { responsive: true },\n    nobs: null\n  },\n  computed: {\n    series: function() {\n      return [{\n        x: this.data,\n        type: 'histogram',\n        nbinsx: this.bins\n      }];\n    }\n  },\n  watch: {\n    nobs: function() {\n      const self = this\n\n      axios\n        .get(`${server}/rand?n=${self.nobs}`)\n        .then(function (response) {\n          self.data = response.data\n        })\n        .catch(function (error) {\n          console.log(error)\n        })\n    },\n    data: function() {\n      Plotly.newPlot('plot', this.series, this.layout, this.config)\n    }\n  },\n  mounted: function() {\n    const self = this\n    self.nobs = 1000\n  },\n  components: {\n    'vueSlider': window[ 'vue-slider-component' ],\n  }\n});\n```\n\n</section>\n\n<section class=\"tab-content\">\n\n```css\n@import url('https://fonts.googleapis.com/css2?family=Open+Sans&display=swap');\n\n#runifapp * {\n  font-family: \"Open Sans\", verdana, arial, sans-serif;\n}\n\n#runifapp p {\n  margin: 0;\n}\n\n#runifapp  .body {\n  display: block;\n  width: 100%;\n}\n\n#runifapp .title h1 {\n  font-size: 30px;\n  font-weight: 500;\n  margin-bottom: 10px;\n}\n\n#runifapp .slidercontainer {\n  display: inline-block;\n  width: calc(30% - 58px);\n  overflow: none;\n  vertical-align: top;\n  border: 1px solid #999;\n  border-radius: 5px;\n  background-color: #eee;\n  padding: 35px 25px 25px 25px;\n}\n\n#runifapp .plotcontainer {\n  display: inline-block;\n  width: 70%;\n}\n```\n\n</section>\n</div>\n</div>\n\nThe application looks as follows:\n\n<a href=\"assets/img/hello_runif_vue.webp\" target=\"_blank\">\n<img src=\"assets/img/hello_runif_vue.webp\" class=\"Large\"/></a>\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}