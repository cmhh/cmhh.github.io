<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>cmhh  | Building Tile Services on-the-fly with GeoServer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.1/css/bulma.min.css" />
    <link href="../../css/highlight/atom-one-dark-reasonable.css" rel='stylesheet' type='text/css' />
    <link rel="stylesheet" href="../../css/blog.css" />
    </head>
<body>

    
    <nav class="navbar is-fixed-top" role="navigation" aria-label="main navigation">
        <div class="navbar-brand">
            <a class="navbar-item" href="../../">Home</a>
            
        </div>
    </nav>
    

    
    <section class="hero is-info is-medium">
        <div class="hero-body" style="background-image: url(/img/bg-blog-2.jpg);">
            <div class="container has-text-centered">
                <br>
                <h1 class="title is-size-1">
                    
                        Building Tile Services on-the-fly with GeoServer
                    
                </h1>
                
            </div>
        </div>
    </section>


<div class="container">
    <div class="section">
    

<div class="columns">
    <div class="column is-9">
        <div class="tile is-child box">
            <div class="content">
                


<p><link rel="stylesheet" type="text/css" href="../../css/custom.css"></p>
<div id="overview" class="section level1">
<h1>Overview</h1>
<p>Interactive web applications can be a great way to present information to a diverse audience. If your interface is well designed and intuitive, then almost anybody will be able to use it. And where data has a spatial dimension, slippy maps can be an effective way of presenting information. But sometimes the objects we want to render are a bit on the large side. This means that our web browser can struggle to render all the required features, and it also means that mobile users of an app might end up using excessive amounts of data.</p>
<p>A good solution to the problem, that the spatial features we need to display are large, is to use some sort of tile service. Slippy maps can, for the most part, fetch information from a tile service only for the active extent. So, here we look at using <a href="https://geoserver.org">GeoServer</a> as a means of publishing such services. We put special emphasis on ease of use and deployment, so cover the following:</p>
<ul>
<li>the use of Docker to simplify the installation and deployment of GeoServer itself</li>
<li>the use of GeoServer’s REST API</li>
<li>wrapping calls to GeoServer’s REST API to simplify a number of common use cases</li>
</ul>
<p>Specifically, we’ll demonstrate how we can create new tile services on-the-fly entirely within R (though we could use any language capable of making HTTP calls and manipulating geospatial data–Python with geopandas, for example).</p>
<video width="878" controls>
<source src="../../vid/geoserver.mp4" type="video/mp4">
<p>Your browser does not support the video tag.
</video></p>
<p><strong>Note that there is already an R package, <a href="https://github.com/eblondel/geosapi"><code>geosapi</code></a>, that provides what looks like a largely complete wrapper for the GeoServer REST API.</strong> I wasn’t aware of it when I put this together. The use case here is a bit different, but nevertheless could possibly have made use of the geosapi package.</p>
</div>
<div id="a-comment-on-spatial-formats" class="section level1">
<h1>A comment on spatial formats</h1>
<p>In this overview we work exclusively with GeoPackages. Of course shapefile is somewhat ubiquitous–it’s readily available, and most GIS tools can work with it easily. But shapefile is a proprietary format with a lot of very real drawbacks. GeoPackage, on the other hand, is an open format built on SQLite which has few, if any, of the same drawbacks, and is widely supported in mainstream GIS tools.</p>
<p>Converting shapefile to GeoPackage is relatively easy if you have access to <a href="https://gdal.org/">GDAL</a>:</p>
<pre class="bash"><code>$ ogr2ogr -f GPKG output.gpkg input.shp</code></pre>
<div id="source-data" class="section level2">
<h2>Source data</h2>
<p>Throughout this document, we use spatial features sourced from
<a href="https://datafinder.stats.govt.nz">Stats NZ geographic data service</a>. Specifically:</p>
<ul>
<li><a href="https://datafinder.stats.govt.nz/layer/92198-meshblock-2018-clipped-generalised/">Meshblock 2018 Clipped (generalised)</a></li>
<li><a href="https://datafinder.stats.govt.nz/layer/92211-statistical-area-1-2018-clipped-generalised/">Statistical Area 1 2018 (genaralised)</a></li>
<li><a href="https://datafinder.stats.govt.nz/layer/92213-statistical-area-2-2018-clipped-generalised/">Statistical Area 2 2018 (generalised)</a></li>
<li><a href="https://datafinder.stats.govt.nz/layer/92215-territorial-authority-2018-clipped-generalised/">Territorial Authority 2018 Clipped (generalised)</a></li>
<li><a href="https://datafinder.stats.govt.nz/layer/92205-regional-council-2018-clipped-generalised/">Regional Council 2018 Clipped (generalised)</a></li>
</ul>
<p>In addition, we also combine this with contextual information found on <a href="http://nzdotstat.stats.govt.nz/wbos/Index.aspx?_ga=2.229484444.1460045830.1566778650-200579101.1566001142">NZ.Stat</a>:</p>
<ul>
<li><a href="http://nzdotstat.stats.govt.nz/wbos/Index.aspx?DataSetCode=TABLECODE7979">Subnational population estimates (RC, SA2), by age and sex, at 30 June 1996, 2001, 2006-18 (2018 boundaries)</a></li>
<li><a href="http://nzdotstat.stats.govt.nz/wbos/Index.aspx?DataSetCode=TABLECODE7980">Subnational population estimates (TA, SA2), by age and sex, at 30 June 1996, 2001, 2006-18 (2018 boundaries)</a></li>
</ul>
</div>
<div id="installation" class="section level2">
<h2>Installation</h2>
<p>To install the R package used throughout this document, simply run:</p>
<pre class="r"><code>devtools::install_github(&quot;cmhh/geoserveR&quot;)</code></pre>
<p>The R package requires a running instance of GeoServer to be useful. We can get GeoServer up and running easily using Docker. There is <a href="https://wiki.osgeo.org/wiki/DockerImages">no shortage of existing images online</a>, but we’ll build our own. We do this because it’s pretty straight forward, and because it’s instructive. The R package contains a Dockerfile in <code>docker/Dockerfile</code> as follows:</p>
<pre class="dockerfile"><code>FROM ubuntu:18.04

ENV DEBIAN_FRONTEND noninteractive

ENV GEOSERVER_VERSION 2.15.2

RUN apt-get update &amp;&amp; \
  apt-get install -y \
    ca-certificates openssl wget openjdk-8-jre \
    openssh-server openssh-client unzip &amp;&amp; \
  apt-get clean &amp;&amp; \
  update-ca-certificates &amp;&amp; \
  cd /usr/local &amp;&amp; \
  wget http://sourceforge.net/projects/geoserver/files/GeoServer/${GEOSERVER_VERSION}/geoserver-${GEOSERVER_VERSION}-bin.zip &amp;&amp; \
  unzip geoserver-${GEOSERVER_VERSION}-bin.zip &amp;&amp; \
  mv geoserver-${GEOSERVER_VERSION} geoserver &amp;&amp; \
  rm geoserver-${GEOSERVER_VERSION}-bin.zip

ENV GEOSERVER_HOME /usr/local/geoserver

ENV GEOSERVER_DATA_DIR ${GEOSERVER_HOME}/data_dir

EXPOSE 8080

CMD [&quot;sh&quot;, &quot;/usr/local/geoserver/bin/startup.sh&quot;]</code></pre>
<p>The R package can be used to generate the command required to build the image since the location of <code>Dockerfile</code> will vary depending on the user’s setup. For example:</p>
<pre class="r"><code>&gt; geoserveR::docker_build(tag = &#39;geoserver&#39;)
docker build -t geoserver &quot;/home/cmhh/R/x86_64-pc-linux-gnu-library/3.5/geoserveR/docker&quot;</code></pre>
<p>Running the resulting command at the terminal will result in the creation of an image called, in this case, <code>geoserver</code>. We can start this via:</p>
<pre class="bash"><code>$ docker run -d --name geoserver --rm -p 8080:8080 geoserver</code></pre>
<p>The container will take a short while to get up and running completely, but when done, simply open a browser at <code>http://localhost:8080/geoserver</code>. To login, the username is <code>admin</code>, and the password is <code>geoserver</code> (obviously, we’d configure this differently in a production setting… more on that later). And that’s it.</p>
<div class="figure">
<img src="../../img/geoserveR/geoserver001.png" alt="http://localhost:8080/geoserver" />
<p class="caption"><code>http://localhost:8080/geoserver</code></p>
</div>
</div>
<div id="testing-geoserver" class="section level2">
<h2>Testing GeoServer</h2>
<p>GeoServer includes several data sources by default, and we can use these to test out our install. We’re mostly interested in WMS services which we can display on a leaflet map, though GeoServer can display WCS, WFS, WMS, and WMTS.</p>
<p>Broadly speaking, GeoServer groups sets of <em>layers</em> together in <em>workspaces</em>, where the layers are the features we’re intrested in displaying on a map. And the layers themselves are built up from <em>data stores</em>. We can inspect workspaces in the main web interface by clicking the Data &gt; Workpaces link:</p>
<div class="figure">
<img src="../../img/geoserveR/workspaces.png" alt="Workspaces" />
<p class="caption">Workspaces</p>
</div>
<p>Any of the listed workspaces can then be accessed as WMS services programmatically via <code>http://localhost/geoserver/&lt;workspace&gt;/wms?</code> (and an XML file describing the service can be accessed via <code>http://localhost/geoserver/&lt;workspace&gt;/wms?request=GetCapabilities</code>). For example, if we wanted to display layers that are part of the <code>topp</code> workspace, we’d use <code>http://localhost:8080/geoserver/topp/wms?</code>. If we click on Data &gt; Layers in the main web interface we see that there is, for example, a layer in the <code>topp</code> workspace called <code>states</code>:</p>
<div class="figure">
<img src="../../img/geoserveR/layers.png" alt="Layers" />
<p class="caption">Layers</p>
</div>
<p>We can display this in a leaflet map in R by running the following code:</p>
<pre class="r"><code>library(leaflet)

leaflet() %&gt;%
  addTiles(
    urlTemplate = &quot;https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png&quot;
  ) %&gt;%
  leaflet::fitBounds(-125, 25, -67, 50) %&gt;%
  addWMSTiles(
    &quot;http://localhost:8080/geoserver/topp/wms?&quot;, 
    layers = &quot;states&quot;,
    options = WMSTileOptions(format = &quot;image/png&quot;, transparent = TRUE)
  )</code></pre>
<p>which yields the following:</p>
<div class="figure">
<img src="../../img/geoserveR/states.png" alt="states" />
<p class="caption">states</p>
</div>
</div>
<div id="an-r-client-library" class="section level2">
<h2>An R client library</h2>
<p>Our use case is to create styled tiles services, entirely from within R. To simplify the discussion, a simple R package is provided which:</p>
<ul>
<li>includes geographies (as <code>sf</code> objects)</li>
<li>includes population counts (as a tidy <code>data.frame</code>)</li>
<li>includes an interface for (a subset of) the GeoServer REST API</li>
<li>includes utilities that simplify working with the GeoServer interface.</li>
</ul>
<p>We won’t go into the details here, but rather just describe the relevant usage as it arises. Where possible, though, we will also consider the plain HTTP calls. But by way of example, the following lists the layers available in the <code>topp</code> workspace. First, using the REST API (via <code>curl</code>):</p>
<pre class="bash"><code>$ curl -s -u admin:geoserver -X GET \
    http://localhost:8080/geoserver/rest/workspaces/topp/layers | jq &#39;.&#39;</code></pre>
<pre class="json"><code>{
  &quot;layers&quot;: {
    &quot;layer&quot;: [
      {
        &quot;name&quot;: &quot;states&quot;,
        &quot;href&quot;: &quot;http://localhost:8080/geoserver/rest/workspaces/topp/layers/states.json&quot;
      },
      {
        &quot;name&quot;: &quot;tasmania_cities&quot;,
        &quot;href&quot;: &quot;http://localhost:8080/geoserver/rest/workspaces/topp/layers/tasmania_cities.json&quot;
      },
      {
        &quot;name&quot;: &quot;tasmania_roads&quot;,
        &quot;href&quot;: &quot;http://localhost:8080/geoserver/rest/workspaces/topp/layers/tasmania_roads.json&quot;
      },
      {
        &quot;name&quot;: &quot;tasmania_state_boundaries&quot;,
        &quot;href&quot;: &quot;http://localhost:8080/geoserver/rest/workspaces/topp/layers/tasmania_state_boundaries.json&quot;
      },
      {
        &quot;name&quot;: &quot;tasmania_water_bodies&quot;,
        &quot;href&quot;: &quot;http://localhost:8080/geoserver/rest/workspaces/topp/layers/tasmania_water_bodies.json&quot;
      }
    ]
  }
}</code></pre>
<p>and then using the provided R package:</p>
<pre class="r"><code>&gt; library(geoserveR)
&gt; gs &lt;- GeoServer$new()
&gt; topp_layers &lt;- gs$getLayers(&quot;topp&quot;)
&gt; str(topp_layers)
List of 5
 $ states                   :List of 2
  ..$ name: chr &quot;states&quot;
  ..$ href: chr &quot;http://localhost:8080/geoserver/rest/workspaces/topp/layers/states.json&quot;
 $ tasmania_cities          :List of 2
  ..$ name: chr &quot;tasmania_cities&quot;
  ..$ href: chr &quot;http://localhost:8080/geoserver/rest/workspaces/topp/layers/tasmania_cities.json&quot;
 $ tasmania_roads           :List of 2
  ..$ name: chr &quot;tasmania_roads&quot;
  ..$ href: chr &quot;http://localhost:8080/geoserver/rest/workspaces/topp/layers/tasmania_roads.json&quot;
 $ tasmania_state_boundaries:List of 2
  ..$ name: chr &quot;tasmania_state_boundaries&quot;
  ..$ href: chr &quot;http://localhost:8080/geoserver/rest/workspaces/topp/layers/tasmania_state_boundaries.json&quot;
 $ tasmania_water_bodies    :List of 2
  ..$ name: chr &quot;tasmania_water_bodies&quot;
  ..$ href: chr &quot;http://localhost:8080/geoserver/rest/workspaces/topp/layers/tasmania_water_bodies.json&quot;</code></pre>
</div>
<div id="making-a-new-layer" class="section level2">
<h2>Making a new layer</h2>
<p>Pretty much any layer that exists in GeoServer can be made available as a service–WMS in our case. We’ll run through a couple of examples, but, broadly speaking, the steps are:</p>
<ul>
<li>create a <em>workspace</em></li>
<li>add a <em>datastore</em> to the workspace</li>
<li>add a <em>style</em> via a styled layer descriptor (sld) file</li>
<li>add a <em>layer</em> to the workspace which references the data store and style</li>
</ul>
<p>We’ll put all our examples in a single workspace named <code>statsnz</code>. We can create this in R as follows:</p>
<pre class="r"><code>library(geserveR)

gs &lt;- GeoServer$new()
gs$createWorkspace(&quot;statsnz&quot;)</code></pre>
</div>
<div id="example---meshblock-with-labels" class="section level2">
<h2>Example - meshblock with labels</h2>
<p>Meshblocks are the building blocks of most other official geographies held by Stats NZ. There are approximately 50,000 of them and collectively they are quite large–the GeoPackage used here was 91MB, though we simplified this considerably using <a href="https://mapshaper.org/">mapshaper</a> to make things practical. To display them in R on a leaflet map:</p>
<pre class="r"><code>library(geoserveR)
library(leaflet)

leaflet() %&gt;%
  addTiles(urlTemplate = &quot;https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png&quot;) %&gt;%
  addPolygons(data = mb2018, 
              color = &quot;#000000&quot;, weight = 1, opacity = 1, fillOpacity = 0,
              label = ~code)</code></pre>
<p>This yields something like the following:</p>
<div class="figure">
<img src="../../img/geoserveR/leaflet001.png" alt="meshblocks" />
<p class="caption">meshblocks</p>
</div>
<p>Saved as a stand-alone HTML file, this weighs in at over 15MB, and can be sluggish when rendering. In actuality, the features are oversimplified here, so that when zoomed in the shapes have lost far too much detail. But if we’d displayed them at full resolution, our HTML file would be over 100MB!</p>
<p>To make meshblocks available as a service, we first add a datastore. We can add this in R as follows:</p>
<pre class="r"><code>gs$createDatastore(mb2018, &quot;statsnz&quot;, &quot;mb2018&quot;)</code></pre>
<p>Internally, this creates a copy of the <code>mb2018</code> feature class as a GeoPackage, and then uploads it to the server via the <code>datastores</code> endpoint. We then make a layer in R as follows:</p>
<pre class="r"><code>style &lt;- import_template(
  &quot;outline_with_label&quot;,
  name = &quot;mb2018_with_labels&quot;, strokeColor = &quot;#000000&quot;, strokeWidth = 1,
  maxScale = 600000, geometryName = &quot;geom&quot;, labelName = &quot;code&quot;,
  fontFamily = &quot;Arial&quot;, fontSize = 9, fontStyle = &quot;normal&quot;,
  fontWeight = &quot;bold&quot;, fontColor = &quot;#000000&quot;,
  haloSize = 1.5, haloColor = &quot;#FFFFFF&quot;
)

gs$createLayer(&quot;statsnz&quot;, &quot;mb2018&quot;, &quot;mb2018_with_labels&quot;, style)</code></pre>
<p>Internally, we create a <em>feature type</em>, which is initially unconfigured. We then create a new style, and then we apply the style to the created layer. The variable <code>style</code> contains styling information in styled layer descriptor (SLD) format. The approach here isn’t terribly refined, but it is practical. The <code>import_template</code> function is used to import bundled templates, and replace placeholders with parameter values.</p>
<p>Either way, having done all this, we can now access meshblocks as a WMS via <code>http://localhost:8080/statsnz/wms?</code> as follows:</p>
<pre class="r"><code>leaflet() %&gt;%
  fitBounds(lng1 = 164.45, lng2 = 179.35, lat1 = -48.52, lat2 = -33.22) %&gt;%
  addTiles(
    urlTemplate = &quot;https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png&quot;
  ) %&gt;%
  addWMSTiles(
    &quot;http://localhost:8080/geoserver/statsnz/wms?&quot;, 
    layers = &quot;mb2018_with_labels&quot;,
    options = WMSTileOptions(format = &quot;image/png&quot;, transparent = TRUE), 
    group = &quot;mb2018&quot;
  ) %&gt;%
  addLayersControl(
    overlayGroups = &quot;mb2018&quot;,
    options = layersControlOptions(collapsed = FALSE)
  )</code></pre>
<p>Visually:</p>
<div class="figure">
<img src="../../img/geoserveR/leaflet003.png" alt="mb2018_with_labels" />
<p class="caption">mb2018_with_labels</p>
</div>
<div class="figure">
<img src="../../img/geoserveR/leaflet004.png" alt="mb2018_with_labels" />
<p class="caption">mb2018_with_labels</p>
</div>
<p>Better yet, saved as a stand-alone HTML file, this map is less than 500KB (though the various tiles still need to be transferred, so one can still burn through a bit of data just navigating around).</p>
</div>
<div id="example---population-by-statistical-area-2" class="section level2">
<h2>Example - population by statistical area 2</h2>
<p>Consider the following R code:</p>
<pre class="r"><code>library(geoserveR)
library(leaflet)
library(sf)
library(dplyr)

data(sa22018)
data(popdata)

mapdata &lt;- sa22018 %&gt;%
  inner_join(filter(popdata, geography == &quot;sa22018&quot;), by = &quot;code&quot;) %&gt;%
  filter(year == 2018)

pal &lt;- colorNumeric(palette = &quot;Blues&quot;, domain = mapdata$value)

leaflet() %&gt;%
  addTiles(urlTemplate = &quot;https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png&quot;) %&gt;%
  addPolygons(data = mapdata, 
              fillColor = ~pal(value), opacity = 0, fillOpacity = 1,
              label = ~sprintf(&quot;%s - %s&quot;, label, value)) %&gt;%
  addLegend(position = &quot;bottomright&quot;, pal = pal, values = mapdata$value)</code></pre>
<p>This yields an interactive map as follows:</p>
<div class="figure">
<img src="../../img/geoserveR/leaflet002.png" alt="population by SA2" />
<p class="caption">population by SA2</p>
</div>
<p>The resulting HTML file weighs in at 3.2MB–not enormous by any stretch, but still probably not something you want users to be fetching repeatedly over a mobile connection, for example. But this map just shows data for 2018, yet we have data for the years 1996, 2001, and 2006-2018–that’s 15 years all up. What if we want to make all this available on one map? In that case, the resulting stand-alone HTML file weighs in at over 40MB. (Of course, a hosted app could serve up a year based on user selection, but 3MB or so would still be transferred each time the year was switched).</p>
<p>Let us instead see if we can create a workspace in GeoServer which contains a layer for each year. As a WMS, the layers will cease to be interactive (so no hovering tooltips), but we could at least render a label whenever the user zooms in close enough, so let’s do that too.</p>
<p>First, we create a version of the SA2 feature class that has population counts:</p>
<pre class="r"><code>library(dplyr)
library(reshape2)

counts &lt;- popdata %&gt;%
  dplyr::filter(geography == &quot;sa22018&quot;) %&gt;%
  dplyr::select(-geography)

counts_wide &lt;- counts %&gt;%
  reshape2::dcast(code ~ year, value.var = &quot;value&quot;) %&gt;%
  data.frame # this is deliberate so years are like X1996 rather than `1996`

sa22018_with_counts &lt;- sa22018 %&gt;%
  inner_join(counts_wide, by = &quot;code&quot;)</code></pre>
<p>Then, we create a data store using the feature class created, and add a new layer for each of the columns:</p>
<pre class="r"><code>gs &lt;- GeoServer$new()

gs$createDatastore(sa22018_with_counts, &quot;statsnz&quot;, &quot;sa22018_with_counts&quot;)

years &lt;- c(1996, 2001, 2006:2018)

for (year in years) {
  col &lt;- sprintf(&quot;X%s&quot;, year)
  name &lt;- sprintf(&quot;sa22018_%s&quot;, year)
  style &lt;- create_polygon_fills(sa22018_with_counts, col, &quot;geom&quot;, &quot;label&quot;)
  gs$createLayer(&quot;statsnz&quot;, &quot;sa22018_with_counts&quot;, name, style) 
}</code></pre>
<p>And that’s it—we now have a bunch of new layers called <code>sa22018_1996</code>, and so on. There’s a little bit going on under the hood, of course, but either way we can now use the resulting WMS layers as follows:</p>
<pre class="r"><code>m &lt;- leaflet() %&gt;%
  fitBounds(lng1 = 164.45, lng2 = 179.35, lat1 = -48.52, lat2 = -33.22) %&gt;%
  addTiles(
    urlTemplate = &quot;https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png&quot;
  )

for (year in years) {
  m &lt;- m %&gt;%
    addWMSTiles(
      &quot;http://localhost:8080/geoserver/statsnz/wms?&quot;,
      layers = sprintf(&quot;sa22018_%s&quot;, year),
      options = WMSTileOptions(format = &quot;image/png&quot;, transparent = TRUE),
      group = as.character(year)
    ) %&gt;%
    hideGroup(as.character(year))
}

m %&gt;%
  addLayersControl(
    overlayGroups = as.character(years),
    options = layersControlOptions(collapsed = TRUE)
  ) %&gt;%
  showGroup(as.character(tail(years, 1)))</code></pre>
<p>which yields:</p>
<div class="figure">
<img src="../../img/geoserveR/leaflet05.png" alt="sa22018_with_counts" />
<p class="caption">sa22018_with_counts</p>
</div>
<div class="figure">
<img src="../../img/geoserveR/leaflet06.png" alt="sa22018_with_counts" />
<p class="caption">sa22018_with_counts</p>
</div>
<!--
## Extension&ndash;adding PostGIS to our Docker image

Throughout the demo we just used shapefiles.  Shapefiles are useful in the sense that 
-->
</div>
<div id="appendix---api-calls" class="section level2">
<h2>Appendix - API calls</h2>
<p>For the sake of brevity, the examples above mostly focused on R calls using the provided R client library. For the sake of completeness, and for those who might want to do something similar without R, we include the equivalent functionality using direct API calls.</p>
<div id="creating-a-workspace" class="section level3">
<h3>Creating a workspace</h3>
<p>To make the <code>statsnz</code> workspace, we ran:</p>
<pre class="r"><code>library(geserveR)

gs &lt;- GeoServer$new()
gs$createWorkspace(&quot;statsnz&quot;)</code></pre>
<p>To do this direclty, we use the <code>workspaces</code> endpoint:</p>
<pre class="bash"><code>curl \
  -u admin:geoserver \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;workspace&quot;:{&quot;name&quot;:&quot;statsnz&quot;}}&#39; \
  -X POST \
  http://localhost:8080/geoserver/rest/workspaces</code></pre>
</div>
<div id="creating-a-datastore" class="section level3">
<h3>Creating a datastore</h3>
<p>To add the meshblock feature set as a datastore, we ran the following in R:</p>
<pre class="r"><code>gs$createDatastore(mb2018, &quot;statsnz&quot;, &quot;mb2018&quot;, &quot;mb2018.gpkg&quot;)</code></pre>
<p>Internally, this results in <code>mb2018</code> first being saved as a temporary GeoPackage, before being uploaded via the <code>datastores</code> endpoint. If we wanted to do this manually, we’d first create the GeoPackage in R:</p>
<pre class="r"><code>fname &lt;- tempfile(fileext = &quot;.gpkg&quot;)
st_write(regc2018, fname, &quot;mb2018&quot;)</code></pre>
<p>and then we’d <code>PUT</code> via the <code>datastores</code> endpoint as follows (assuming <code>fname</code> has the value <code>file4b82655cefdd.gpkg</code>):</p>
<pre class="bash"><code>curl \
  -u admin:geoserver \
  -H &quot;Accept: application/json, text/xml, application/xml, */*&quot; \
  -H &quot;Content-Type: application/octet-stream&quot; \
  -T &quot;/tmp/RtmpbY5Tby/file4b82655cefdd.gpkg&quot; \
  -X PUT \
  &quot;http://localhost:8080/geoserver/rest/workspaces/statsnz/datastores/regc2018/file.gpkg?configure=none&amp;update=overwrite&amp;charset=UTF-8&amp;filename=mb2018.gpkg&quot;</code></pre>
</div>
<div id="creating-a-layer" class="section level3">
<h3>Creating a layer</h3>
<p>To create a meshblock layer with a simple outline and text label, we ran the following in R:</p>
<pre class="r"><code>style &lt;- import_template(
  &quot;outline_with_label&quot;,
  name = &quot;mb2018_with_labels&quot;, strokeColor = &quot;#000000&quot;, strokeWidth = 1,
  maxScale = 600000, geometryName = &quot;geom&quot;, labelName = &quot;code&quot;,
  fontFamily = &quot;Arial&quot;, fontSize = 9, fontStyle = &quot;normal&quot;,
  fontWeight = &quot;bold&quot;, fontColor = &quot;#000000&quot;,
  haloSize = 1.5, haloColor = &quot;#FFFFFF&quot;
)

gs$createLayer(&quot;statsnz&quot;, &quot;mb2018&quot;, &quot;mb2018_with_labels&quot;, style)</code></pre>
<p>Assuming we have saved the content of the variable <code>style</code> in a file called <code>style.sld</code>, we could create the style on the server as follows:</p>
<pre class="bash"><code>curl \
  -u admin:geoserver \
  -H &quot;Accept: application/json, text/xml, application/xml, */*&quot; \
  -H &quot;Content-Type: application/vnd.ogc.sld+xml&quot; \
  --data &quot;@style.sld&quot; \
  -X POST \
  &quot;http://localhost:8080/geoserver/rest/workspaces/statsnz/styles?name=mb2018_with_label&quot;</code></pre>
<p>We’d create the feature type as:</p>
<pre class="bash"><code>curl \
  -u admin:geoserver \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;featureType&quot;:{&quot;name&quot;:&quot;mb2018_with_labels&quot;, &quot;nativeName&quot;:&quot;mb2018&quot;}}&#39; \
  -X POST \
  &quot;http://localhost:8080/geoserver/rest/workspaces/statsnz/datastores/mb2018/featuretypes&quot;</code></pre>
<p>and we’d add the style to the layer as:</p>
<pre class="bash"><code>curl \
  -u admin:geoserver \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;layer&quot;:{&quot;defaultStyle&quot;:{&quot;name&quot;:&quot;statsnz:labelledpolygon&quot;}}}&#39; \
  -X PUT \
  &quot;http://localhost:8080/geoserver/rest/workspaces/statsnz/layers/mb2018&quot;</code></pre>
</div>
</div>
</div>

            </div>
        </div>
    </div>
    <div class="column is-3">
        <div class="card">
    <div class="card-content">
        <h1 class="title is-5">Tags</h1>
        <div class="tags">
        
            <span class="tag"><a href="../../tags/akka-http">akka-http</a></span>
        
            <span class="tag"><a href="../../tags/geoserver">geoserver</a></span>
        
            <span class="tag"><a href="../../tags/geospatial">geospatial</a></span>
        
            <span class="tag"><a href="../../tags/node.js">node.js</a></span>
        
            <span class="tag"><a href="../../tags/osrm">osrm</a></span>
        
            <span class="tag"><a href="../../tags/qgis">qgis</a></span>
        
            <span class="tag"><a href="../../tags/r">r</a></span>
        
            <span class="tag"><a href="../../tags/r-packages">r-packages</a></span>
        
            <span class="tag"><a href="../../tags/seasonal-adjustment">seasonal-adjustment</a></span>
        
            <span class="tag"><a href="../../tags/shiny">shiny</a></span>
        
            <span class="tag"><a href="../../tags/tiles">tiles</a></span>
        
            <span class="tag"><a href="../../tags/tilestache">tilestache</a></span>
        
            <span class="tag"><a href="../../tags/wmts">wmts</a></span>
        
            <span class="tag"><a href="../../tags/x13-arima-seats">x13-arima-seats</a></span>
        
        </div>          
    </div>
</div><br>
        <div class="card">
    <div class="card-content">
        <h1 class="title is-5">Recent posts</h1>
        
            <h1><a href="../../post/seasadj/">Seasonal Adjustment as a Service</a></h1>
            <time class="has-text-grey-light is-size-7">1 June 2020</time>
        
            <h1><a href="../../post/geoserver/">Building Tile Services on-the-fly with GeoServer</a></h1>
            <time class="has-text-grey-light is-size-7">17 September 2019</time>
        
            <h1><a href="../../post/qgis/">Web Maps and Tiles with QGIS</a></h1>
            <time class="has-text-grey-light is-size-7">26 January 2017</time>
        
            <h1><a href="../../post/tiles/">Serving Geospatial Features with Mapnik and TileStache</a></h1>
            <time class="has-text-grey-light is-size-7">28 November 2016</time>
        
            <h1><a href="../../post/routing/">Routing in R Using the Open Source Routing Machine (OSRM)</a></h1>
            <time class="has-text-grey-light is-size-7">27 November 2016</time>
        
    </div>
</div>
    <br>
                
  



<div class="card">
    <div class="card-content">
        <h1 class="title is-5">Related posts</h1>
      
      
            <h1><a href="../../post/routing/">Routing in R Using the Open Source Routing Machine (OSRM)</a></h1>
            <time class="has-text-grey-light is-size-7">27 November 2016</time>
      
            <h1><a href="../../post/datapackages/">Using R Packages to Disseminate Data</a></h1>
            <time class="has-text-grey-light is-size-7">20 July 2016</time>
      
    </div>
</div>

    
<br>
        <div class="card">
    <div class="card-content">
        <h1 class="title is-5">Archives</h1>
        
            <a href="../../archives/2020">2020</a> (1)<br>
        
            <a href="../../archives/2019">2019</a> (1)<br>
        
            <a href="../../archives/2017">2017</a> (1)<br>
        
            <a href="../../archives/2016">2016</a> (4)<br>
        
    </div>
</div>

    </div>
</div>


    </div>
</div>

<footer class="footer has-background-grey-darker has-text-white">
    <div class="content has-text-centered">
        <p>
            <span class="icon is-large"><a href="https://github.com/cmhh" class="mysocial" rel="me"><i class="fab fa-github fa-3x"></i></a></span>&nbsp;&nbsp;
            <span class="icon is-large"><a href="mailto://cmhhansen@outlook.com" class="mysocial" rel="me"><i class="fas fa-envelope fa-3x"></i></a></span>&nbsp;&nbsp;
            <br><br>
            Copyright &copy; cmhh 2020 - Theme by <a href="https://jeffprod.com" class="mysocial">JeffProd.com</a>
        </p>
    </div>
</footer>

<script defer src="https://use.fontawesome.com/releases/v5.1.0/js/all.js"></script>
<script src="../../js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
