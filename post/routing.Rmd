---
title: "Routing in R Using the Open Source Routing Machine (OSRM)"
author: "Chris Hansen"
date: "2016-11-27"
categories: ["R", "geospatial"]
output: 
   html_document
params:
   app_id: "QKVVOf49NWwt2vGhe0It"
   app_code: "iHDViQ2uA1X04cUopmQuYg"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(comment = NA, echo = TRUE, cache = FALSE,
                      fig.align = "center",
                      warning = FALSE, message = FALSE)
```

<link rel="stylesheet" type="text/css" href="/css/custom.css">

# Overview

I often find myself needing to establish the travel time or distance between
arrays of addresses.  In the past I have used ArcMap's Network Analyst tool,
but have found the syntax to be clunky at best, and the performance to be very
mediocre.  And, besides, I am often working in R and sometimes it's nice to be
able to do everything in the one environment, rather than doing the routing in
Python, say, and then using the results in R.  

The [open source routing machine](http://project-osrm.org/) is a very fast
routing engine which can be accessed via an
[HTTP API](https://github.com/Project-OSRM/osrm-backend/blob/master/docs/http.md),
which means it can be queried relatviely easy from most languages, including R.
And while public servers are available for use, it is also relatively easy to
set up locally resulting in excellent throughput due to the lack of latency.


# Prerequisites

The following R pacakges are required:

* `rjson` for reading web service results in JSON format
* `bitops` used to decode polylines (has convenient bitshift operators, etc.)
* `sp` for spatial projections, etc.
* `leaflet` for rendering <a href="http://leafletjs.com/">leaflet</a> maps in 
  a browser
  

# Geocoding addresses

The <a href="https://developers.google.com/maps/documentation/geocoding/">Google 
Geocoding API</a> is used to geocode addresses.  Usage is free, but the free 
license is limited to 2500 requests per day, at a rate no faster than 5 per 
second.  There are free alternatives, but I've not found any that are 
satisfactorally accurate for New Zealand addresses.  That said, interesting
alternatives worth keeping an eye on are:

* [data science toolkit](http://www.datasciencetoolkit.org/) - doesn't work at
all for New Zealand
* [Nominatim](http://wiki.openstreetmap.org/wiki/Nominatim) - finds   addresses
but probably only okay if approximate locations are acceptable.
  
The following code results in two addresses being geocoded which we will use
as an origin and a destination later when using a routing service.

```{r geocode}
library(rjson)

# use HERE API to geocode a start point...
get_location <- function(search_text, 
                         app_id = params$app_id, app_code = params$app_code) {
   service <- "https://geocoder.api.here.com/6.2/geocode.json"
   query <- sprintf(
     "%s?app_id=%s&app_code=%s&searchtext=%s",
     service, app_id, app_code,
     gsub(" ", "%20", search_text, fixed = TRUE)
   )
   
   res1 <- jsonlite::fromJSON(query, simplifyVector = FALSE)
   res2 <- res1$Response$View[[1]]$Result[[1]]$Location
   
   list(
      lng = res2$DisplayPosition$Longitude, 
      lat = res2$DisplayPosition$Latitude, 
      address = res2$Address$Label
   )
}

# start point...
(o <- get_location("25 Edelweiss Grove, Timberlea, Upper Hutt"))

# ...and destination
(d <- get_location("1 Pipitea Street, Wellington"))
```


# Open Source Routing Machine (OSRM)

<a href="http://project-osrm.org/">Open Source Routing Machine</a> is an open
source route solver.  It is written in C++ and runs on Linux (maybe other
platforms, but stick with Linux), and is very fast.  There is a nice web demo
which uses the service as a back-end
<a href="http://map.project-osrm.org/">here</a>.  The back-end service is
available to the public at
[https://router.project-osrm.org](https://router.project-osrm.org).
Details, including usage policy, is available
<a href="https://github.com/Project-OSRM/osrm-backend/wiki/API Usage Policy">
here</a>. 

The code below shows how to find a route between the origin and destination 
locations found above:

```{r route}
(url <- paste0("http://cmhh.hopto.org/osrm/route/v1/driving/", 
   o$lng,",",o$lat,";",d$lng,",",d$lat,"?overview=full"))

system.time({
  route <- jsonlite::fromJSON(url, simplifyVector = FALSE)
})
```

Again, assuming a route was successfully found, `route` will now contain a list
including, among other things, time in seconds to traverse the route, distance
in metres, and the route geomertry stored in 
[encoded polyline algorithm format](https://developers.google.com/maps/documentation/utilities/polylinealgorithm).

```{r summary}
route$routes[[1]]$duration
route$routes[[1]]$distance
route$routes[[1]]$geometry
```

We write a function to convert the encoded route to a `SpatialLines` object:

```{r decode}
decode <- function(str, multiplier=1e5){
   
   if (!require(bitops)) stop("Package: bitops required.")
   if (!require(sp)) stop("Package: sp required.")
   
   truck <- 0
   trucks <- c()
   carriage_q <- 0
   
   for (i in 0:(nchar(str)-1)){
      ch <- substr(str, (i+1), (i+1))
      x <- as.numeric(charToRaw(ch)) - 63
      x5 <- bitShiftR(bitShiftL(x, 32-5), 32-5)
      truck <- bitOr(truck, bitShiftL(x5, carriage_q))
      carriage_q <- carriage_q + 5
      islast <- bitAnd(x, 32) == 0
      if (islast){
         negative <- bitAnd(truck, 1) == 1
         if (negative) truck <- -bitShiftR(-bitFlip(truck), 1)/multiplier
         else truck <- bitShiftR(truck, 1)/multiplier
         trucks <- c(trucks, truck)
         carriage_q <- 0
         truck <- 0
      }
   }
   lat <- trucks[c(T,F)][-1]
   lng <- trucks[c(F,T)][-1]
   res <- data.frame(lat=c(trucks[1],cumsum(lat)+trucks[1]), 
                     lng=c(trucks[2],cumsum(lng)+trucks[2]))

   coordinates(res) <- ~lng+lat
   proj4string(res) <- CRS("+init=epsg:4326")
   return(SpatialLines(list(Lines(Line(res), 1)), CRS("+init=epsg:4326")))
}
```
```{r plot, message=FALSE, out.width=810, dpi=96}
par(mar=par()$mar-c(1,0,2.5,0), cex=0.8)
path <- decode(route$routes[[1]]$geometry, multiplier=1e5)
plot(path); axis(1); axis(2); box()
```


# Using ```leaflet``` to make a nicer map

It is relatively easy to make a nice interactive map.  Here we draw a simple
<a href="http://leafletjs.com/">leaflet</a> map, and overlay the origin and
destination points, as well as the route between.

```{r makemap}
#make a string to nicely label the route
s <- route$routes[[1]]$duration
kms <- round(route$routes[[1]]$distance/1000, 1)
routelabel <- paste0(s%/%60, "m ", s%%60, "s , ", kms, "kms")

#create a basic map
library(leaflet)
m <- leaflet(width="100%") %>% 
  addTiles()  %>% 
  addPolylines(data=path, popup=routelabel, color = "#000000", opacity=1, weight = 3) %>%
  addMarkers(lng=o$lng, lat=o$lat, popup=o$address) %>%
  addMarkers(lng=d$lng, lat=d$lat, popup=d$address)
```
```{r plotmap, cache=FALSE}
m
```

It's also relatively straight forward to use different base maps, and a nice 
demo of some other providers can be found 
<a href="http://leaflet-extras.github.io/leaflet-providers/preview/">here</a>.
For example:

```{r basemaps, cache=FALSE}
require(leaflet)
leaflet(width="100%", height=600) %>% 
  addTiles(urlTemplate='http://{s}.tile.stamen.com/watercolor/{z}/{x}/{y}.png') %>%
  addTiles(urlTemplate='http://{s}.tile.openstreetmap.se/hydda/roads_and_labels/{z}/{x}/{y}.png') %>%
  addPolylines(data=path, popup=routelabel, color = "#000000", opacity=1, weight = 3) %>%
  addMarkers(lng = o$lng, lat = o$lat, popup = o$address) %>%
  addMarkers(lng = d$lng, lat = d$lat, popup = d$address)
```
