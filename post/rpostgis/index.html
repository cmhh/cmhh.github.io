<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>cmhh  | Using PostGIS as a Spatial Backend for R</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.1/css/bulma.min.css" />
    <link href="https://cmhh.github.io/css/highlight/atom-one-dark-reasonable.css" rel='stylesheet' type='text/css' />
    <link rel="stylesheet" href="https://cmhh.github.io/css/blog.css" />
    <link rel="stylesheet" href="https://cmhh.github.io/css/custom.css" />
</head>
<body>

    
    <nav class="navbar is-fixed-top" role="navigation" aria-label="main navigation">
        <div class="navbar-brand">
            <a class="navbar-item" href="https://cmhh.github.io/">Home</a>
            
        </div>
    </nav>
    

    
    <section class="hero is-info is-medium">
        <div class="hero-body" style="background-image: url(https://cmhh.github.io/img/bg-blog-2.jpg);">
            <div class="container has-text-centered">
                <br>
                <h1 class="title is-size-1">
                    
                        Using PostGIS as a Spatial Backend for R
                    
                </h1>
                
            </div>
        </div>
    </section>


<div class="container">
    <div class="section">
    

<div class="columns">
    <div class="column is-9">
        <div class="tile is-child box">
            <div class="content">
                
<script src="../../rmarkdown-libs/header-attrs/header-attrs.js"></script>
<link href="../../rmarkdown-libs/anchor-sections/anchor-sections.css" rel="stylesheet" />
<script src="../../rmarkdown-libs/anchor-sections/anchor-sections.js"></script>


<div id="overview" class="section level1">
<h1>Overview</h1>
<p>R is a wildly extensible tool, and that extensibility means it can be used in a surprising array of domains. This versatility is great, but there are times when R is just not the best tool for the job–at least not by itself. Geospatial applications are a good example. Packages such as <code>rgdal</code>, <code>sf</code>, and <code>raster</code> make R quite usable in this domain, but R’s largely in-memory approach can make geoprocessing tasks involving large spatial objects a little challenging. In this blog, we look at how we can leverage <a href="https://www.postgresql.org/">PostgreSQL</a> and the <a href="https://postgis.net/">PostGIS</a> extension to usefully complement R, mostly by offloading large geoprocessing tasks, and as a library for storing large feature classes for shared use across a potentially large userbase.</p>
</div>
<div id="source-data" class="section level1">
<h1>Source Data</h1>
<p>In this demonstration we will use <a href="https://www.openstreetmap.org/#map=2/-41.2/-6.6">OpenStreetMap</a> data sourced from <a href="http://download.geofabrik.de">Geofabrik</a>. Specifically, <a href="http://download.geofabrik.de/australia-oceania/new-zealand-latest-free.shp.zip">New Zealand (.shp.zip)</a>. Unpacked, this provides a number of feature classes, but we will be interested mainly in <code>gis_osm_landuse_a_free_1</code>, which contains polygons describing land use–forest, farm, nature reserves, etc. This data is provided as a set of ESRI Shapefiles.</p>
<!--:

file                       | type    | description
---------------------------|---------|------------------
gis_osm_buildings_a_free_1 | polygon |
gis_osm_landuse_a_free_1   | polygon | 
gis_osm_natural_a_free_1   | polygon | 
gis_osm_natural_free_1     | point   | 
gis_osm_places_a_free_1    | polygon | 
gis_osm_places_free_1      | point   | 
gis_osm_pofw_a_free_1      | polygon | places of worship
gis_osm_pofw_free_1        | point   | places of worship
gis_osm_pois_a_free_1      | polygon | points of interest
gis_osm_pois_free_1        | point   | points of interest
gis_osm_railways_free_1    | line    | 
gis_osm_roads_free_1       | line    | 
gis_osm_traffic_a_free_1   | polygon | parking, fuel, etc.
gis_osm_traffic_free_1     | point   | parking, fuel, etc.
gis_osm_transport_a_free_1 | polygon | stations, terminals, etc.
gis_osm_transport_free_1   | point   | stations, terminals, etc.
gis_osm_water_a_free_1     | polygon | 
gis_osm_waterways_free_1   | line    | 
-->
<p>Additionally, we will use <a href="https://datafinder.stats.govt.nz/layer/104280-meshblock-2020-generalised/">Meshblock 2020 (generalised)</a> sourced from <a href="https://datafinder.stats.govt.nz/">Stats NZ Geographic Data Service</a>. This is a standard geographic grouping used by Stats NZ out of which all other higher geographies (Statistical Area levels 1 and 2, Territorial Authority, Regional Council, etc.) are created. This data can be downloaded in a range of formats, and GeoPackage was chosen for the purpose of this post.</p>
<!--
* [Territorial Authority 2020 Clipped (generalised)](https://datafinder.stats.govt.nz/layer/104266-territorial-authority-2020-clipped-generalised/) 
* [Regional Council 2020 Clipped (generalised)](https://datafinder.stats.govt.nz/layer/104253-regional-council-2020-clipped-generalised/)
* [Statistical Area Level 1 2020 Clipped (generalised)](https://datafinder.stats.govt.nz/layer/104272-statistical-area-1-2020-clipped-generalised/)
* [Statistical Area Level 2 2020 Clipped (generalised)](https://datafinder.stats.govt.nz/layer/104270-statistical-area-2-2020-clipped-generalised/)
* [Meshblock 2020 (generalised)](https://datafinder.stats.govt.nz/layer/104280-meshblock-2020-generalised/)
-->
<p>Finally we will make use of <a href="https://data.linz.govt.nz/layer/95524-wellington-010m-urban-aerial-photos-2017/">Wellington 0.10m Urban Aerial Photos (2017)</a> from the <a href="https://data.linz.govt.nz/">LINZ Data Service</a>. This is a set of high resolution aerial imagery covering Wellington City. This data can be downloaded in a range of formats, and JPEG was chosen here.</p>
<!-- * [Wellington 0.10m Urban Aerial Photos (2017)](https://data.linz.govt.nz/layer/95524-wellington-010m-urban-aerial-photos-2017/) -->
</div>
<div id="loading-the-source-data-to-postgis" class="section level1">
<h1>Loading the Source Data to PostGIS</h1>
<p>In principle, we can create spatial tables in a PostGIS-enabled database by running SQL queries. Of course, that’s not practical beyond trivially simple use cases. In practice, we will copy compatible files into the database using one of the following methods:</p>
<ul>
<li>using command-line tools that come with PostGIS, such as <code>shp2pgsql</code></li>
<li>using command-line tools that come with GDAL, such as <code>ogr2ogr</code></li>
<li>using a client library, such as the <code>rpostgis</code> or <code>rgdal</code> packages in R</li>
</ul>
<div id="vector-data" class="section level2">
<h2>Vector data</h2>
<p>We can load vector data to PostGIS using the <code>ogr2ogr</code> program provided by <code>gdal</code>. For example, in the following we load a GeoPackage called <code>meshblock-2020-generalised.gpkg</code> to <code>statsnz.meshblock2020</code>:</p>
<pre class="bash"><code>ogr2ogr \
  -f PostgreSQL PG:&quot;dbname=&#39;gis&#39; user=&#39;gisuser&#39; password=&#39;gisuser&#39;&quot; \
  meshblock-2020-generalised.gpkg \
  -nln statsnz.meshblock2020</code></pre>
<p>In this case the geodatabase has a single layer, so we don’t need to specify it explicitly. And note that on occasion it might be necessary to specify the type explicitly, for example by adding <code>-nlt MULTIPOLYGON</code>.</p>
<p>We can also load vector data using the <code>shp2pgsql</code> utility that is provided with PostGIS. It only works for shapefiles, however. So, to load the data this way we’d first convert it to a shapefile as follows:</p>
<pre class="bash"><code>ogr2ogr \
  -f &#39;ESRI Shapefile&#39; mb2020.shp \
  meshblock-2020-generalised.gpkg</code></pre>
<p>and then use <code>shp2pgsql</code> to load it to a PostGIS table:</p>
<pre class="bash"><code>shp2pgsql -s 2193 mb2020.shp statsnz.meshblock2020 | psql -d gis</code></pre>
<p>Note that <code>shp2pgsql</code> actually just creates a large SQL script, and that is executed in the same way as any other. <code>ogr2ogr</code> can also be used to create a SQL script which can be loaded directly to our database:</p>
<pre class="bash"><code>ogr2ogr -f PGDUMP mb2020.sql \
  meshblock-2020-generalised.gpkg \
  -nln statsnz.meshblock2020</code></pre>
<p>Actually, this approach should be preferred since transferring to shapefile as an intermediate step will cause attribute names to be truncated / normalised, and if the GeoPackage contains indexes, comments, and so forth, they will be retained.</p>
<p>Finally, one could load the data via R itself, though it probably isn’t the best approach in general. Still, to load the same GeoPackage:</p>
<pre class="r"><code>library(sf)

conn &lt;- RPostgreSQL::dbConnect(
  &quot;PostgreSQL&quot;, host = &quot;localhost&quot;, port = 5432,
  dbname = &quot;gis&quot;, user = &quot;gisuser&quot;, password = &quot;gisuser&quot;
)

mb &lt;- st_read(&quot;meshblock-2020-generalised.gpkg&quot;)
st_write(mb, conn, c(&quot;statsnz&quot;, &quot;meshblock2020&quot;))
DBI::dbDisconnect(conn)</code></pre>
</div>
<div id="raster-data" class="section level2">
<h2>Raster data</h2>
<p>GDAL only offers read-only support for PostGIS currently (I think), so there are two options for loading rasters: using the <code>raster2pgsql</code> command-line tool provided by PostGIS, or using the <code>rpostgis::pgWriteRast</code> function in R.</p>
<p>One advantage of the <code>raster2pgsql</code> approach is that we can wildcard a large number of input files. For example, for this blog, the <a href="https://data.linz.govt.nz/layer/95524-wellington-010m-urban-aerial-photos-2017/">Wellington aerial imagery</a> was downloaded as an archive containing 1667 jpeg files. These can be loaded as <code>linz.wellington-010m-urban-aerial-2017</code> as follows:</p>
<pre class="bash"><code>raster2pgsql \
  -I -C -e -Y -F -s 2193 -t 100x100 -l 2,4 \
  *.jpg linz.wellington_010m_2017 | psql -U gisuser -d gis</code></pre>
<p>There are some interesting options here. Using <code>-e</code> means each file will be run as an independent query, rather than all running as a single transaction. Using <code>-l 2,4</code> means that lower resolution (1/2 and 1/4) versions of the raster will be added to new tables called <code>o_2_wellington_010m_2017</code> and <code>o_4_wellington_010m_2017</code>, respectively. See <a href="https://postgis.net/docs/using_raster_dataman.html">Raster Data Management, Queries, and Applications</a>.</p>
<p>Loading the data via R is possible, though not as straightforward. In this case, while not recommended, we could do something like:</p>
<pre class="r"><code>library(rpostgis)

conn &lt;- RPostgreSQL::dbConnect(
  &quot;PostgreSQL&quot;, host = &quot;localhost&quot;, port = 5432,
  dbname = &quot;gis&quot;, user = &quot;gisuser&quot;, password = &quot;gisuser&quot;
)

files &lt;- dir(&quot;/home/cmhh/Downloads/shp/linz&quot;, full.names = TRUE)
files &lt;- files[grepl(&quot;*.jpg$&quot;, files)]
l &lt;- lapply(files, function(f) {
  pgWriteRast(
    conn, 
    c(&quot;linz&quot;, &quot;wellington_010m_2017&quot;), 
    stack(f), 
    append = TRUE
  )
})

DBI::dbDisconnect(conn)</code></pre>
</div>
</div>
<div id="practical-examples" class="section level1">
<h1>Practical Examples</h1>
<p>In this section we demonstrate a small number of practical use cases that are probably relatively common in many workflows. We will start with a pure R approach in each case (if possible), before contrasting it with an equivalent approach which leverages PostGIS.</p>
<p>Note that all operations in this section were conducted on a single machine with 16GB of RAM and a Intel® Core™ i7-9750H CPU @ 2.60GHz × 12 processor.</p>
<div id="transforming-reprojecting-and-simplifying-features" class="section level2">
<h2>Transforming / reprojecting and simplifying features</h2>
<p>Consider the <code>osm.gis_osm_landuse_a_free_1</code> feature class. This is reasonably large, consisting of some 373272 features, and totalling 327MB as a shapefile on disk. The features themselves are polygons that describe various types of land use, a section of which looks as follows:</p>
<p><a href="../../img/rpostgis/upperhuttlanduse.png" target="_blank">
<img src="../../img/rpostgis/upperhuttlanduselo.png" class="large">
</a></p>
<p>Assume we wish to do the following:</p>
<ul>
<li>read the shapefile</li>
<li>convert to EPSG 2193 (New Zealand Tranverse Mercator 2000)</li>
<li>simplify with 1 metre tolerance.</li>
</ul>
<p>To do this in R, we might do the following:</p>
<pre class="r"><code>library(sf)

landuse_nztm_1m &lt;- 
  st_read(&quot;gis_osm_landuse_a_free_1.shp&quot;) %&gt;%
  st_transform(2193) %&gt;%
  st_simplify(preserveTopology = TRUE, dTolerance = 1)</code></pre>
<p>Peak memory use during this operation was approximately 2.5GB, and the operation took 63 seconds. This same task can be conducted from R, but leaning heavily on PostGIS, by pulling the results of a SQL query as follows:</p>
<pre class="r"><code>conn &lt;- RPostgreSQL::dbConnect(
  &quot;PostgreSQL&quot;, host = &quot;localhost&quot;, port = 5432,
  dbname = &quot;gis&quot;, user = &quot;gisuser&quot;, password = &quot;gisuser&quot;
)
  
landuse_nztm &lt;- st_read(
  conn, 
  query = &quot;
    SELECT 
      gid, osm_id, code, fclass, name, 
      ST_Simplify(ST_Transform(wkb_geometry, 2193), 1.0, FALSE) as geom 
    FROM 
      osm.gis_osm_landuse_a_free_1
  &quot;
)</code></pre>
<p>Peak memory usage throughout was 1.5GB, and the total execution time was 19.4 seconds. In this case, then, PostGIS consumed 1GB (40%) less memory, and was 43.6 seconds (69%) faster than an in-memory approach using the <code>sf</code> package.</p>
<!--
## Intersecting two large features

Maybe do building outlines for a single SA2 or something?
-->
</div>
<div id="dissolving-features" class="section level2">
<h2>Dissolving features</h2>
<p>A feature class can be dissolved by some categorical attribute using the <code>sf</code> package simply by performing a grouped aggregate, in this case with <code>dplyr</code>:</p>
<pre class="r"><code>library(dplyr)

mb_dissolved_sf &lt;- 
  st_read(&quot;meshblock-2020-generalised.gpkg&quot;) %&gt;%
  group_by(LANDWATER_NAME) %&gt;%
  summarise(n = n())</code></pre>
<p>Peak memory use for this was about 530MB, and total execution time was 65.1 seconds.</p>
<pre class="r"><code>mb_dissolved &lt;- st_read(
  conn, 
  query = &quot;
    SELECT
      landwater_name, ST_Multi(ST_Union(geom)) as geom
    FROM 
      statsnz.meshblock2020
    GROUP BY 
      landwater_name
  &quot;
)</code></pre>
<p>Peak memory use for this was about 480MB, and total execution time was 67.9 seconds. Importantly, peak memory usage for R itself was much smaller at 132.3MB.</p>
<p>The result either way can be plotted using the <code>geom_sf</code> geometry for <code>ggplot2</code>. Before dissolving we have:</p>
<pre class="r"><code>library(ggplot2)

ggplot() + 
  geom_sf(
    data = st_read(&quot;meshblock-2020-generalised.gpkg&quot;), 
    aes(fill = LANDWATER_NAME)
  ) +
  guides(fill = guide_legend(title = &quot;&quot;))</code></pre>
<div class="large">
<p><img src="../../img/rpostgis/mb.png" /></p>
</div>
<p>After dissolving we have:</p>
<pre class="r"><code>ggplot() + 
  geom_sf(
    data = mb_dissolved_sf, 
    aes(fill = LANDWATER_NAME), linetype = &quot;blank&quot;
  ) +
  guides(fill = guide_legend(title = &quot;&quot;))</code></pre>
<div class="large">
<p><img src="../../img/rpostgis/mbdissolve.png" /></p>
</div>
</div>
<div id="clipping-a-large-raster" class="section level2">
<h2>Clipping a large raster</h2>
<p>The <a href="https://data.linz.govt.nz/layer/95524-wellington-010m-urban-aerial-photos-2017/">Wellington 0.10m Urban Aerial Photos (2017)</a> raster was downloaded in JPEG format. Unpacked, the ‘raster’ is 5.4GB, and is made up of 1667 individual JPEG files, each about 3.5MB in size. Collectively, they look as follows:</p>
<p><a href="../../img/rpostgis/wgtnaerial01.jpeg" target="_blank">
<img src="../../img/rpostgis/wgtnaerial01lo.jpeg" class="large">
</a></p>
<p>In principle, these can be imported into R using the raster package. For example, to create a raster from the first 2 JPEG files:</p>
<pre class="r"><code>f &lt;- dir(&quot;/home/cmhh/Downloads/shp/linz&quot;, full.names = TRUE)
f &lt;- f[grepl(&quot;^.+(.jpg)$&quot;, f)]
r &lt;- merge(brick(f[1]), brick(f[2]))</code></pre>
<p>which yields:</p>
<p><a href="../../img/rpostgis/wgtnaerial02.jpeg" target="_blank">
<img src="../../img/rpostgis/wgtnaerial02lo.jpeg" class="large">
</a></p>
<p>In practice, however, this approach is excruciatingly slow, and far from practical. (Loading the raster to PostGIS is also excruciatingly slow, but it only needs to be done once, and then many users can use the result.) Now consider this same raster with the <code>statsnz.meshblock2020</code> feature class overlaid:</p>
<p><a href="../../img/rpostgis/wgtnaerial03.jpeg" target="_blank">
<img src="../../img/rpostgis/wgtnaerial03lo.jpeg" class="large">
</a></p>
<p>Assume that we just wish to use a single meshblock, 2122700, to mask the raster. This can be done in R using the <code>gdalUtils::gdalwarp</code> function (which is just a wrapper for the <code>gdalwarp</code> command-line tool) as follows:</p>
<pre class="r"><code>library(gdalUtils)

gdalwarp(
  srcfile = &quot;
    PG: dbname=&#39;gis&#39; host=127.0.0.1 port=5432 
    user=&#39;gisuser&#39; password=&#39;gisuser&#39; mode=2 
    schema=&#39;linz&#39; column=&#39;rast&#39; 
    table=&#39;wellington_010m_2017&#39;
  &quot;,
  dstfile = &quot;2122700.tif&quot;,
  s_src = &quot;EPSG:2193&quot;, 
  t_srs = &quot;EPSG:2193&quot;,
  multi = TRUE,
  cutline = &quot;
    PG:dbname=&#39;gis&#39; host=127.0.0.1 port=5432 
    user=&#39;gisuser&#39; password=&#39;gisuser&#39;
  &quot;,
  csql = &quot;
    select geom 
    from statsnz.meshblock2020 
    where mb2020_v1_00 = &#39;2122700&#39;
  &quot;,
  crop_to_cutline = TRUE,
  dstnodata = &quot;nodata&quot;
)</code></pre>
<p>Note that this took only a few seconds in practice, and outputs a single TIF file which can be read into R using <code>raster::stack("2122700.tif")</code>, and looks as follows:</p>
<p><a href="../../img/rpostgis/wgtnrail.jpeg" target="_blank">
<img src="../../img/rpostgis/wgtnraillo.jpeg" class="small">
</a></p>
</div>
</div>
<div id="extensions" class="section level1">
<h1>Extensions</h1>
<p>PostGIS has a number of other uses. One interesting use case is to pair it with <a href="http://geoserver.org/">GeoServer</a> so feature classes can be served as WMS features which can be included in <a href="https://leafletjs.com/">Leaflet</a> maps. For an example of using GeoServer from R to create tile services on the fly, see <a href="../../post/geoserver/">Building Tile Services on-the-fly with GeoServer</a>.</p>
<div style="padding-bottom: 10px;">
<video width="878" controls>
<source src="../../vid/geoserver.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>
<p>Note that GeoServer supports the use of rasters, though it is a little involved. See, for example, <a href="https://docs.geoserver.org/latest/en/user/data/raster/imagemosaic/index.html#data-imagemosaic">GeoServer User Manual - ImageMosaic</a>.</p>
<p>Another method of using PostGIS to serve features is via <a href="https://github.com/CrunchyData/pg_tileserv">pg_tileserv</a> or <a href="https://github.com/CrunchyData/pg_featureserv">pg_featureserv</a>. The first is used to serve PostGIS feature tables as tiles, the second will serve PostGIS feature tables in a range of OGC API formats. All of this might make for an interesting follow-up post in the future.</p>
</div>
<div id="appendix---installing-dependencies" class="section level1">
<h1>Appendix - Installing Dependencies</h1>
<p>For this demonstration, one can deploy all required software via Docker containers. This ensures it is very easy to reproduce everything shown here if desired.</p>
<div id="installing-docker" class="section level2">
<h2>Installing Docker</h2>
<p>Docker is relatively easy to install on Linux systems. Reasonably new versions will sometimes be available from standard repositories, but newer version can be obtained for most distributions by following the instructions:</p>
<p><a href="https://docs.docker.com/engine/install/">Install Docker Engine</a></p>
<p>While Windows users can run Linux containers via <a href="https://docs.docker.com/docker-for-windows/install/">Docker Desktop</a>, they are strongly encouraged to enable the Windows Subsystem for Linux version 2 (WSL2), and instead install Docker on Linux. For a rundown on using Docker via WSL2 see:</p>
<p><a href="../../post/docker_wsl2/">Docker on Windows with Windows Subsystem for Linux 2</a></p>
<p>I have no experience with Docker on a Mac, but <a href="https://docs.docker.com/docker-for-mac/install/">Docker Desktop</a> is available. It has apparently had performance issues in the past, though newer versions might be much better. The release notes for version 2.3.5.0 (2020-08-21) have the following promising inclusion:</p>
<blockquote>
<p>Docker Desktop now uses gRPC-FUSE for file sharing by default. This has much faster file sharing and uses much less CPU than osxfs, especially when there are lots of file events on the host. To switch back to osxfs, go to Preferences &gt; General and disable gRPC-FUSE.</p>
</blockquote>
</div>
<div id="installing-postgresql-and-postgis" class="section level2">
<h2>‘Installing’ PostgreSQL and PostGIS</h2>
<p>There are Docker images available which contain both PostgreSQL and PostGIS, though it is instructive to create one. First, create a file called <code>Dockerfile</code> with the following content:</p>
<pre class="dockerfile"><code>FROM ubuntu:20.04

ENV DEBIAN_FRONTEND=noninteractive
ENV SHELL=/bin/bash

RUN  apt-get update &amp;&amp; apt-get -y dist-upgrade &amp;&amp; \
  apt-get install -y --no-install-recommends \
    wget gnupg2 ca-certificates gdal-bin sudo vim &amp;&amp; \
  sh -c &#39;echo &quot;deb http://apt.postgresql.org/pub/repos/apt focal-pgdg main&quot; &gt; /etc/apt/sources.list.d/pgdg.list&#39; &amp;&amp; \
  wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add - &amp;&amp; \
  apt-get update &amp;&amp; apt-get install -y --no-install-recommends postgresql-13 postgresql-13-postgis-3 postgis &amp;&amp; \
  apt-get clean &amp;&amp; \
  rm -rf /var/lib/apt/lists/*

RUN service postgresql start &amp;&amp; \
  sudo -u postgres psql -c &#39;create database gis;&#39; &amp;&amp; \
  sudo -u postgres psql -d gis -c &#39;create extension postgis;&#39; &amp;&amp; \
  sudo -u postgres psql -d gis -c &#39;create extension postgis_raster;&#39; &amp;&amp; \
  sudo -u postgres psql -d gis -c &#39;create extension postgis_sfcgal;&#39; &amp;&amp; \
  sudo -u postgres psql -d gis -c &#39;create extension postgis_topology;&#39; &amp;&amp; \
  sudo -u postgres psql -d gis -c &quot;SET postgis.gdal_enabled_drivers = &#39;ENABLE_ALL&#39;;&quot; &amp;&amp; \
  sudo -u postgres psql -c &#39;create user gisuser;&#39; &amp;&amp; \
  sudo -u postgres psql -c &quot;alter user gisuser with encrypted password &#39;gisuser&#39;;&quot; &amp;&amp; \
  sudo -u postgres psql -c &#39;grant all privileges on database gis to gisuser;&#39; &amp;&amp; \
  printf &quot;\tlisten_addresses=&#39;*&#39;\t&quot; &gt;&gt; /etc/postgresql/13/main/postgresql.conf &amp;&amp; \
  sed -i -E &#39;/local +all +all +peer/ s/peer/md5/&#39; /etc/postgresql/13/main/pg_hba.conf &amp;&amp; \
  sed -i -E &#39;/host +all +all +127.0.0.1\/32 +md5/ s/127.0.0.1\/32/0.0.0.0\/0   /&#39; /etc/postgresql/13/main/pg_hba.conf &amp;&amp; \
  sed -i -E &#39;/host +all +all +::1\/128 +md5/ s/::1\/128/::0\/0  /&#39; /etc/postgresql/13/main/pg_hba.conf &amp;&amp;\ 
  printf &quot;localhost:5432:gis:gisuser:gisuser&quot; &gt;&gt; /root/.pgpass &amp;&amp; \
  chmod 0600 /root/.pgpass

EXPOSE 5432

CMD service postgresql start &amp;&amp; \
  tail -f /dev/null  </code></pre>
<p>To build the image, change into the directory containing <code>Dockerfile</code> and run:</p>
<pre class="bash"><code>docker build -t postgis .</code></pre>
<p>If we wish to persist our database, we can create a volume as so:</p>
<pre class="bash"><code>docker volume create pgdata</code></pre>
<p>Then, to run an instance with the volume mounted, as well as a folder containing all the required source features (if desired):</p>
<pre class="bash"><code>docker run \
  -d --rm --name postgis \
  -p 5432:5432 \
  -v /path/to/downloaded/data:/data \
  -v pgdata:/var/lib/postgresql/13/main \
  postgis</code></pre>
<p>To gain terminal access to the running container, run:</p>
<pre class="bash"><code>docker exec -it postgis bash</code></pre>
</div>
<div id="installing-r-and-required-spatial-dependencies" class="section level2">
<h2>‘Installing’ R and required spatial dependencies</h2>
<p>To create a Linux container with R and RStudio Server, create a file called <code>Dockerfile</code> with content as follows:</p>
<pre class="dockerfile"><code>FROM ubuntu:20.04

ARG rstudio_version=1.3.1093
ENV DEBIAN_FRONTEND=noninteractive
ENV SHELL=/bin/bash
ENV RSTUDIO_VERSION=$rstudio_version

# install necessary packages
RUN  apt-get update &amp;&amp; apt-get -y dist-upgrade &amp;&amp; \
  apt-get install -y --no-install-recommends \
    gnupg2 ca-certificates gdebi-core wget odbc-postgresql libblas3 \
    grass gdal-bin libgdal-dev libgeos-dev libproj-dev proj-bin proj-data &amp;&amp; \
  sed -i -e &#39;s/# en_US.UTF-8 UTF-8/en_US.UTF-8 UTF-8/&#39; /etc/locale.gen &amp;&amp; \
  dpkg-reconfigure --frontend=noninteractive locales &amp;&amp; \
  update-locale LANG=en_US.UTF-8 &amp;&amp; \
  wget -qO- &quot;https://yihui.org/gh/tinytex/tools/install-unx.sh&quot; | sh -s - --admin --no-path &amp;&amp; \
  mv /root/.TinyTeX /usr/local/TinyTex &amp;&amp; \
  /usr/local/TinyTex/bin/*/tlmgr path add &amp;&amp; \
  apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E298A3A825C0D65DFD57CBB651716619E084DAB9 &amp;&amp; \
  printf &quot;deb https://cloud.r-project.org/bin/linux/ubuntu focal-cran40/&quot; &gt;&gt; /etc/apt/sources.list &amp;&amp; \
  apt-get update &amp;&amp; apt-get install -y --no-install-recommends r-base &amp;&amp; \
  wget https://download2.rstudio.org/server/bionic/amd64/rstudio-server-${RSTUDIO_VERSION}-amd64.deb &amp;&amp; \
  gdebi rstudio-server-${RSTUDIO_VERSION}-amd64.deb &amp;&amp; \
  rm rstudio-server-${RSTUDIO_VERSION}-amd64.deb &amp;&amp; \
  apt-get clean &amp;&amp; \
  rm -rf /var/lib/apt/lists/* &amp;&amp; \
  R -e &quot;install.packages(c(&#39;renv&#39;, &#39;rgdal&#39;, &#39;rgeos&#39;, &#39;sf&#39;, &#39;leaflet&#39;, &#39;RPostgreSQL&#39;, &#39;rpostgis&#39;))&quot; &amp;&amp; \
  wget https://download2.rstudio.org/server/bionic/amd64/rstudio-server-${RSTUDIO_VERSION}-amd64.deb &amp;&amp; \
  gdebi --non-interactive rstudio-server-${RSTUDIO_VERSION}-amd64.deb &amp;&amp; \
  rm rstudio-server-${RSTUDIO_VERSION}-amd64.deb

# add user for demo purposes
RUN adduser --disabled-password --gecos &quot;&quot; guest &amp;&amp; \
  usermod --password $(openssl passwd -1 guest) guest &amp;&amp; \
  usermod -aG sudo guest 

EXPOSE 8787

CMD service rstudio-server start &amp;&amp; \
  tail -f /dev/null</code></pre>
<p>To build this container, simply change into the directory containing <code>Dockerfile</code> and run:</p>
<pre class="bash"><code>docker build -t rstudio .</code></pre>
<p>The image can be started by running:</p>
<pre class="bash"><code>docker run -d --rm --name rstudio -p 8787:8787 rstudio</code></pre>
<p>When done, RStudio will be available via a web browser at <code>http://localhost:8787</code>.</p>
<p><img src="../../img/rpostgis/rdocker.png" /></p>
</div>
</div>

            </div>
        </div>
    </div>
    <div class="column is-3">
        <div class="card">
    <div class="card-content">
        <h1 class="title is-5">Tags</h1>
        <div class="tags">
        
            <span class="tag"><a href="https://cmhh.github.io/tags/akka-http">akka-http</a></span>
        
            <span class="tag"><a href="https://cmhh.github.io/tags/docker">docker</a></span>
        
            <span class="tag"><a href="https://cmhh.github.io/tags/geoserver">geoserver</a></span>
        
            <span class="tag"><a href="https://cmhh.github.io/tags/geospatial">geospatial</a></span>
        
            <span class="tag"><a href="https://cmhh.github.io/tags/nodejs">nodejs</a></span>
        
            <span class="tag"><a href="https://cmhh.github.io/tags/osrm">osrm</a></span>
        
            <span class="tag"><a href="https://cmhh.github.io/tags/postgis">postgis</a></span>
        
            <span class="tag"><a href="https://cmhh.github.io/tags/postgresql">postgresql</a></span>
        
            <span class="tag"><a href="https://cmhh.github.io/tags/qgis">qgis</a></span>
        
            <span class="tag"><a href="https://cmhh.github.io/tags/r">r</a></span>
        
            <span class="tag"><a href="https://cmhh.github.io/tags/r-packages">r-packages</a></span>
        
            <span class="tag"><a href="https://cmhh.github.io/tags/seasonal-adjustment">seasonal-adjustment</a></span>
        
            <span class="tag"><a href="https://cmhh.github.io/tags/shiny">shiny</a></span>
        
            <span class="tag"><a href="https://cmhh.github.io/tags/tiles">tiles</a></span>
        
            <span class="tag"><a href="https://cmhh.github.io/tags/tilestache">tilestache</a></span>
        
            <span class="tag"><a href="https://cmhh.github.io/tags/vuejs">vuejs</a></span>
        
            <span class="tag"><a href="https://cmhh.github.io/tags/wmts">wmts</a></span>
        
            <span class="tag"><a href="https://cmhh.github.io/tags/wsl2">wsl2</a></span>
        
            <span class="tag"><a href="https://cmhh.github.io/tags/x13-arima-seats">x13-arima-seats</a></span>
        
        </div>          
    </div>
</div><br>
        <div class="card">
    <div class="card-content">
        <h1 class="title is-5">Recent posts</h1>
        
            <h1><a href="https://cmhh.github.io/post/rpostgis/">Using PostGIS as a Spatial Backend for R</a></h1>
            <time class="has-text-grey-light is-size-7">31 October 2020</time>
        
            <h1><a href="https://cmhh.github.io/post/docker_wsl2/">Docker on Windows with Windows Subsystem for Linux 2</a></h1>
            <time class="has-text-grey-light is-size-7">31 October 2020</time>
        
            <h1><a href="https://cmhh.github.io/post/seasadj/">Seasonal Adjustment as a Service</a></h1>
            <time class="has-text-grey-light is-size-7">1 June 2020</time>
        
            <h1><a href="https://cmhh.github.io/post/geoserver/">Building Tile Services on-the-fly with GeoServer</a></h1>
            <time class="has-text-grey-light is-size-7">17 September 2019</time>
        
            <h1><a href="https://cmhh.github.io/post/qgis/">Web Maps and Tiles with QGIS</a></h1>
            <time class="has-text-grey-light is-size-7">26 January 2017</time>
        
    </div>
</div>
    <br>
                
  



<div class="card">
    <div class="card-content">
        <h1 class="title is-5">Related posts</h1>
      
      
            <h1><a href="https://cmhh.github.io/post/geoserver/">Building Tile Services on-the-fly with GeoServer</a></h1>
            <time class="has-text-grey-light is-size-7">17 September 2019</time>
      
            <h1><a href="https://cmhh.github.io/post/routing/">Routing in R Using the Open Source Routing Machine (OSRM)</a></h1>
            <time class="has-text-grey-light is-size-7">27 November 2016</time>
      
            <h1><a href="https://cmhh.github.io/post/datapackages/">Using R Packages to Disseminate Data</a></h1>
            <time class="has-text-grey-light is-size-7">20 July 2016</time>
      
    </div>
</div>

    
<br>
        <div class="card">
    <div class="card-content">
        <h1 class="title is-5">Archives</h1>
        
            <a href="https://cmhh.github.io/archives/2020">2020</a> (3)<br>
        
            <a href="https://cmhh.github.io/archives/2019">2019</a> (1)<br>
        
            <a href="https://cmhh.github.io/archives/2017">2017</a> (1)<br>
        
            <a href="https://cmhh.github.io/archives/2016">2016</a> (4)<br>
        
    </div>
</div>

    </div>
</div>


    </div>
</div>

<footer class="footer has-background-grey-darker has-text-white">
    <div class="content has-text-centered">
        <p>
            <span class="icon is-large"><a href="https://github.com/cmhh" class="mysocial" rel="me"><i class="fab fa-github fa-3x"></i></a></span>&nbsp;&nbsp;
            <span class="icon is-large"><a href="mailto://cmhhansen@outlook.com" class="mysocial" rel="me"><i class="fas fa-envelope fa-3x"></i></a></span>&nbsp;&nbsp;
            <br><br>
            Copyright &copy; cmhh 2020 - Theme by <a href="https://jeffprod.com" class="mysocial">JeffProd.com</a>
        </p>
    </div>
</footer>

<script defer src="https://use.fontawesome.com/releases/v5.1.0/js/all.js"></script>
<script src="https://cmhh.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="//yihui.org/js/math-code.js"></script>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

</body>
</html>
