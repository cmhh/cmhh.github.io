<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Chris Hansen">
<meta name="dcterms.date" content="2022-01-09">
<meta name="description" content="In this post we attempt to approximate a household survey collection as an agent-based simulation. The simulation designed using the actor model, and implemented in Scala using Akka.">

<title>cmhh - Agent Based Simulations with Akka</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<style>
    .quarto-title-block .quarto-title-banner {
      background-image: url(../../img/banner-2.jpg);
background-size: cover;
    }
    </style>


<link rel="stylesheet" href="../../css/styles.css">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">cmhh</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/cmhh" rel=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Agent Based Simulations with Akka</h1>
                  <div>
        <div class="description">
          In this post we attempt to approximate a household survey collection as an agent-based simulation. The simulation designed using the actor model, and implemented in Scala using Akka.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">microsimulation</div>
                <div class="quarto-category">Akka</div>
                <div class="quarto-category">Scala</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Chris Hansen </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 9, 2022</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#the-actor-model" id="toc-the-actor-model" class="nav-link" data-scroll-target="#the-actor-model">The Actor Model</a></li>
  <li><a href="#simulation-overview" id="toc-simulation-overview" class="nav-link" data-scroll-target="#simulation-overview">Simulation Overview</a></li>
  <li><a href="#actors" id="toc-actors" class="nav-link" data-scroll-target="#actors">Actors</a>
  <ul class="collapse">
  <li><a href="#coordinator" id="toc-coordinator" class="nav-link" data-scroll-target="#coordinator"><code>Coordinator</code></a></li>
  <li><a href="#areacoordinator" id="toc-areacoordinator" class="nav-link" data-scroll-target="#areacoordinator"><code>AreaCoordinator</code></a></li>
  <li><a href="#fieldcollectoractor" id="toc-fieldcollectoractor" class="nav-link" data-scroll-target="#fieldcollectoractor"><code>FieldCollectorActor</code></a></li>
  <li><a href="#dwellingactor" id="toc-dwellingactor" class="nav-link" data-scroll-target="#dwellingactor"><code>DwellingActor</code></a></li>
  <li><a href="#individualactor" id="toc-individualactor" class="nav-link" data-scroll-target="#individualactor"><code>IndividualActor</code></a></li>
  <li><a href="#eventrecorder" id="toc-eventrecorder" class="nav-link" data-scroll-target="#eventrecorder"><code>EventRecorder</code></a></li>
  </ul></li>
  <li><a href="#detailed-process-message-protocol" id="toc-detailed-process-message-protocol" class="nav-link" data-scroll-target="#detailed-process-message-protocol">Detailed Process / Message Protocol</a>
  <ul class="collapse">
  <li><a href="#spawn-event-recorder-and-area-coordinators" id="toc-spawn-event-recorder-and-area-coordinators" class="nav-link" data-scroll-target="#spawn-event-recorder-and-area-coordinators">Spawn Event Recorder and Area Coordinators</a></li>
  <li><a href="#spawn-field-collectors" id="toc-spawn-field-collectors" class="nav-link" data-scroll-target="#spawn-field-collectors">Spawn Field Collectors</a></li>
  <li><a href="#spawn-dwellings" id="toc-spawn-dwellings" class="nav-link" data-scroll-target="#spawn-dwellings">Spawn Dwellings</a></li>
  <li><a href="#spawn-individuals" id="toc-spawn-individuals" class="nav-link" data-scroll-target="#spawn-individuals">Spawn Individuals</a></li>
  <li><a href="#simulating-a-days-work" id="toc-simulating-a-days-work" class="nav-link" data-scroll-target="#simulating-a-days-work">Simulating a Day’s Work</a></li>
  </ul></li>
  <li><a href="#analysing-the-simulated-data" id="toc-analysing-the-simulated-data" class="nav-link" data-scroll-target="#analysing-the-simulated-data">Analysing the Simulated Data</a></li>
  </ul>
</nav>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="overview" class="level1">
<h1>Overview</h1>
<p>In this post we describe a relatively simple agent-based simulation. The simulation itself is a rough approximation of a household survey, consisting of a large collection of dwellings, in turn surveyed in a strictly face-to-face setting by one of a number of independent field collectors.</p>
<p>We describe the simulation in terms of the <em>actor model</em>, though we do so in a way that is largely agnostic with respect to programming language or actor framework. Still, a concrete implementation is useful for illustration, and <a href="https://github.com/cmhh/collectionsim">one is provided here</a>. This is implemented using <a href="https://akka.io/">Akka</a>, an implementation of the <a href="https://en.wikipedia.org/wiki/Actor_model">actor model</a> on the JVM, and so some jargon specific to Akka will appear here and there. Nevertheless, it should be easy enough to implement something similar in other frameworks</p>
</section>
<section id="the-actor-model" class="level1">
<h1>The Actor Model</h1>
<p>From <a href="https://en.wikipedia.org/wiki/Actor_model">Wikipedia</a>:</p>
<blockquote class="blockquote">
<p>The actor model in computer science is a mathematical model of concurrent computation that treats <em>actor</em> as the universal primitive of concurrent computation. In response to a message it receives, an actor can: make local decisions, create more actors, send more messages, and determine how to respond to the next message received. Actors may modify their own private state, but can only affect each other directly through messaging (removing the need for lock-based synchronization).</p>
</blockquote>
<p>Akka provides an implementation of the actor model on the JVM which adheres to this definition quite faithfully. We create a set of actors, collectively referred to as an <em>actor system</em>, and actors can only communicate with each other by sending messages. That is, no actor can change or access the internal state of another actor directly. If one actor wishes to know something about another actor, it can request information by sending a message, and the receiving actor can respond with a message in kind. Importantly, messages are just that, and they do not provide direct access to internal state of an actor directly. This means that actors can operate concurrently, but with complete safety–since actors have exclusive access to their state, we do not need to concern ourselves with thread safety or any of the common mitigation strategies, such as synchronized blocks, locks, semaphores, and so on.</p>
<p>As implemented by Akka, actors are free to communicate with any other actor in the system, and functionality does exist that facilitates the discovery of an actor by other actors. However, actors are commonly organised in a hierarchical fashion, typically only communicating with their direct subordinates. In fact, actors can <em>spawn</em> other actors, and this is typically what is meant by subordinate. That is, if actor A spawns actor B, then B is A’s subordinate. Again, this is not a requirement, but it is a useful pattern in practice nevertheless. Taking this hierarchical pattern to the fullest extent, it is common to have a single actor functioning as a broker, or coordinator, between the outside world and the actor system itself.</p>
</section>
<section id="simulation-overview" class="level1">
<h1>Simulation Overview</h1>
<p>At a very high level, our actor system looks as follows:</p>
<p><img src="assets/collectionsim.dot.png" class="img-fluid"></p>
<p>The arrows in the diagram represent responsibility. For example, the inner-most (red) circle is the central coordinator, and is responsible for spawning the area coordinators (green circles), and for passing messages to them. The area coordinators are responsible for spawning field collectors (blue circles), assigning work to them, and forwarding messages to them. Field collectors receive work from area coordinators in the form of addresses, which collectors use in turn to spawn dwellings. Finally, dwellings will each spawn a random set of individuals which will serve as its residents. Field collectors send interview requests to dwellings, and dwellings reply with ‘refusal’, ‘empty’, ‘non-contact’, or ‘response’. If a dwelling is non-empty, and decides to ‘respond’, it sends the parent field collector references to the individuals which the collector then also attempts to contact. We describe the system in more detail in the following sections.</p>
<p>One actor is not shown in the diagram, and that is a single instance of <code>EventRecorder</code>. It is the job of this actor to persist (in a SQLite database) event information we wish to keep after our simulation is finished, and a number of the actors in the system will send information directly to it. It’s a bit clunky (a real-time system might use something like Kafka topics instead, or even Akka’s own streaming functionality, for example), but functional enough for this simple example.</p>
</section>
<section id="actors" class="level1">
<h1>Actors</h1>
<p>We will first describe the various actors at a high level, and then move on to a description of the message protocol and the various sub-processes.</p>
<section id="coordinator" class="level2">
<h2 class="anchored" data-anchor-id="coordinator"><code>Coordinator</code></h2>
<p>There is a single coordinator, an instance of <code>Coordinator</code>, which is our entry-point for the actor system itself. On start-up, the coordinator spawns 6 area coordinators, and its sole responsibility after set-up is to listen for messages from outside the system, and pass them to the appropriate area coordinator. The internal state of the coordinator is just a list of the area coordinators spawned.</p>
</section>
<section id="areacoordinator" class="level2">
<h2 class="anchored" data-anchor-id="areacoordinator"><code>AreaCoordinator</code></h2>
<p>The simulation as configured contains 6 area coordinators, which are instances of <code>AreaCoordinator</code>, and which divide New Zealand up as follows:</p>
<p><img src="assets/collection_areas.png" class="img-fluid"></p>
<p>Area coordinators are responsible for spawning field collectors and for deciding which field collectors will spawn particular dwellings. The internal state of an area coordinator is a list of the the collectors spawned, and a map storing the assignment of dwellings to collectors.</p>
</section>
<section id="fieldcollectoractor" class="level2">
<h2 class="anchored" data-anchor-id="fieldcollectoractor"><code>FieldCollectorActor</code></h2>
<p>Field collectors are instances of <code>FieldCollectorActor</code>, and are spawned by area coordinators. They are assigned a certain number of dwellings, after which it is their responsibility to set about getting responses from those cases. They will typically be sent a message instructing them to simulate a day’s work, assuming a particular starting day and time. This will involve placing all unfinished cases in some efficient driving order, and then visiting each in turn. A field collector will send a dwelling an interview request, and react accordingly. In all cases, time will be advanced by a random amount appropriate for the type of response, and interviewers will stop working once some maximum amount of work has been exceeded.</p>
<p>The internal state of a field collector contains information about itself (id, address, location, name) as well as a configuration object that contains:</p>
<ul>
<li>cases it has been assigned</li>
<li>overall summaries of each case (complete, incomplete, etc.)</li>
<li>work items for the current day</li>
<li>the dwelling being surveyed</li>
<li>the current individual being surveyed</li>
<li>the simulated date and time of day</li>
<li>the total kilometres travelled in the current day</li>
<li>the total minutes spent working in the current day</li>
</ul>
</section>
<section id="dwellingactor" class="level2">
<h2 class="anchored" data-anchor-id="dwellingactor"><code>DwellingActor</code></h2>
<p>Dwellings are instances of <code>DwellingActor</code>, and are spawned by the field collector responsible. Once they are spawned, they will in turn spawn a random set of individuals to function as the dwelling’s residents. A dwelling can respond to interview requests from the field collector which spawned them, avoiding contact, refusing, or providing a full response. After a full response, the dwelling actor will pass the references for any individuals it spawned to the field collector.</p>
<p>The internal state of a dwelling actor contains information about itself (id, address, location), along with a list of all individuals spawned. A dwelling is also aware of whether or not it has responded (that is, sent a complete questionnaire response to its parent collector).</p>
</section>
<section id="individualactor" class="level2">
<h2 class="anchored" data-anchor-id="individualactor"><code>IndividualActor</code></h2>
<p>Individuals function as dwelling residents, and are instances of <code>IndividualActor</code>. All they can do is respond to requests for an interview from field collectors, avoiding contact, refusing, or providing a full response. Individuals are only discovered by field collectors after getting a response from the dwelling that spawned them.</p>
<p>The internal state of an individual contains information about itself (name, age, sex, date of birth), and a reference to its parent dwelling. Like dwellings, individuals are also aware of whether or not they have responded (i.e., provided a questionnaire response to a field collector).</p>
</section>
<section id="eventrecorder" class="level2">
<h2 class="anchored" data-anchor-id="eventrecorder"><code>EventRecorder</code></h2>
<p>The system has a single instance of <code>EventRecorder</code>, and this actor is responsible for persisting information. This might not reflect idiomatic, or best practice; but it works well enough in this case. For example, when a field collector gets a response from an individual, the individual will send a message to the field collector indicating the type of response, but also a JSON string representing a questionnaire response if fully responding. The response itself is then sent, along with identifiers for the dwelling and individual, to the event recorder to persist. Currently, the event recorder stores the following:</p>
<table class="table">
<colgroup>
<col style="width: 21%">
<col style="width: 22%">
<col style="width: 55%">
</colgroup>
<thead>
<tr class="header">
<th>table</th>
<th>from</th>
<th>purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>collectors</code></td>
<td><code>AreaCoordinator</code></td>
<td>A list of all spawned collectors.</td>
</tr>
<tr class="even">
<td><code>dwellings</code></td>
<td><code>FieldCollectorActor</code></td>
<td>A list of all spawned dwellings.</td>
</tr>
<tr class="odd">
<td><code>dwelling_assignment</code></td>
<td><code>FieldCollector</code></td>
<td>Collector and dwelling pairs reflecting work allocation.</td>
</tr>
<tr class="even">
<td><code>dwelling_response</code></td>
<td><code>FieldCollector</code></td>
<td>Completed dwelling questionnaires.</td>
</tr>
<tr class="odd">
<td><code>individual_response</code></td>
<td><code>FieldCollector</code></td>
<td>Completed individual questionnaires.</td>
</tr>
<tr class="even">
<td><code>interview</code></td>
<td><code>FieldCollector</code></td>
<td>All attempted contacts and their outcome.</td>
</tr>
<tr class="odd">
<td><code>trips</code></td>
<td><code>FieldCollector</code></td>
<td>All car trips made by field collectors.</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="detailed-process-message-protocol" class="level1">
<h1>Detailed Process / Message Protocol</h1>
<p>Here we provide additional detail about the overall simulation. The simulation itself is driven largely by the messages that can be understood by the various actors, so the simulation is well described by the message protocol. However, rather than describe the simulation in terms of all possible messages, we instead describe the following broad sub-processes:</p>
<ul>
<li>spawn area coordinators</li>
<li>spawn field collectors</li>
<li>spawn dwellings and individuals</li>
<li>repeatedly simulate a day of work</li>
</ul>
<section id="spawn-event-recorder-and-area-coordinators" class="level2">
<h2 class="anchored" data-anchor-id="spawn-event-recorder-and-area-coordinators">Spawn Event Recorder and Area Coordinators</h2>
<p>The actor system starts with a single coordinator, which is created as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala code-with-copy"><code class="sourceCode scala"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> system <span class="op">=</span> <span class="fu">ActorSystem</span><span class="op">(</span><span class="fu">Coordinator</span><span class="op">(</span>conf<span class="op">.</span><span class="fu">dbpath</span><span class="op">()),</span> <span class="st">"collectionsim"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This coordinator spawns a single event recorder and 6 area coordinators when created. The code looks as follows:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala code-with-copy"><code class="sourceCode scala"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> eventRecorder<span class="op">:</span> ActorRef<span class="op">[</span>EventRecorderCommand<span class="op">]</span> <span class="op">=</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  context<span class="op">.</span><span class="fu">spawn</span><span class="op">(</span><span class="fu">EventRecorder</span><span class="op">(</span>dbpath<span class="op">,</span> <span class="dv">100</span><span class="op">),</span> <span class="st">"eventrecorder"</span><span class="op">)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> areaCoordinators<span class="op">:</span> <span class="ex">Map</span><span class="op">[</span><span class="ex">Area</span><span class="op">,</span> ActorRef<span class="op">[</span>AreaCoordinatorCommand<span class="op">]]</span> <span class="op">=</span> </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  area<span class="op">.</span>areas<span class="op">.</span><span class="fu">map</span><span class="op">(</span>x <span class="op">=&gt;</span> </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>x<span class="op">,</span> context<span class="op">.</span><span class="fu">spawn</span><span class="op">(</span><span class="fu">AreaCoordinator</span><span class="op">(</span>eventRecorder<span class="op">),</span> <span class="ss">s"</span><span class="st">areacoordinator@</span><span class="ss">${</span>x<span class="op">.</span>toString<span class="ss">}"</span><span class="op">))</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">).</span>toMap</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Note that <code>dbpath</code> is the name of the SQLite database which will be created, and 100 is the batch size for writing to the database. That is, a buffer is maintained that contains up to 100 SQL queries–when the buffer is full, the queries are committed to the database.</p>
</section>
<section id="spawn-field-collectors" class="level2">
<h2 class="anchored" data-anchor-id="spawn-field-collectors">Spawn Field Collectors</h2>
<p>Field collector actors are ultimately spawned by passing a message to the coordinator, which is defined as follows:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala code-with-copy"><code class="sourceCode scala"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="kw">class</span> <span class="fu">FieldCollector</span><span class="op">(</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  id<span class="op">:</span> <span class="bu">Int</span><span class="op">,</span> address<span class="op">:</span> <span class="ex">String</span><span class="op">,</span> location<span class="op">:</span> Coordinates<span class="op">,</span> area<span class="op">:</span> <span class="ex">String</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="op">)</span> <span class="kw">extends</span> CoordinatorCommand <span class="kw">with</span> AreaCoordinatorCommand</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This message is passed to the coordinator, the coordinator then forwards it to the correct area coordinator, and the area coordinator then spawns a new collector. The area coordinator also sends a message to the event recorder to be persisted. Visually:</p>
<p><img src="assets/fieldcollector.png" class="img-fluid"></p>
<p>(Note I got a Wacom tablet recently, which is awesome, but I’m new to any sort of digital drawing process, and the hand-eye coordination is taking some time. So, this is the best I can do for now! Sorry.)</p>
<p>Collectors can be provided by a CSV (or gzipped CSV) file, and an iterator can be used to read such files row-by-row, converting each row to an instance of <code>FieldCollector</code>, before being passed to the coordinator. For example, the <a href="https://github.com/cmhh/collectionsim">simulation source</a> includes a file, <a href="https://github.com/cmhh/collectionsim/raw/main/data/interviewers.csv.gz">interviewers.csv.gz</a>, consisting of 100 locations, and the first few rows look as follows:</p>
<table class="table">
<colgroup>
<col style="width: 10%">
<col style="width: 54%">
<col style="width: 6%">
<col style="width: 13%">
<col style="width: 13%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">address_id</th>
<th style="text-align: left;">full_address</th>
<th style="text-align: center;">region</th>
<th style="text-align: right;">lng</th>
<th style="text-align: right;">lat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">236594</td>
<td style="text-align: left;">258 Hereford Street, Christchurch Central, Christchurch</td>
<td style="text-align: center;">13</td>
<td style="text-align: right;">172.6452</td>
<td style="text-align: right;">-43.53221</td>
</tr>
<tr class="even">
<td style="text-align: center;">1535707</td>
<td style="text-align: left;">26 Harris Road, Pokuru</td>
<td style="text-align: center;">3</td>
<td style="text-align: right;">175.2201</td>
<td style="text-align: right;">-38.02346</td>
</tr>
<tr class="odd">
<td style="text-align: center;">617660</td>
<td style="text-align: left;">125 Westminster Avenue, Tamatea, Napier</td>
<td style="text-align: center;">6</td>
<td style="text-align: right;">176.8741</td>
<td style="text-align: right;">-39.50367</td>
</tr>
<tr class="even">
<td style="text-align: center;">582666</td>
<td style="text-align: left;">49 Cambridge Terrace, Kaiti, Gisborne</td>
<td style="text-align: center;">5</td>
<td style="text-align: right;">178.0384</td>
<td style="text-align: right;">-38.67728</td>
</tr>
<tr class="odd">
<td style="text-align: center;">2096666</td>
<td style="text-align: left;">206/155 Beach Road, Auckland Central, Auckland</td>
<td style="text-align: center;">2</td>
<td style="text-align: right;">174.7741</td>
<td style="text-align: right;">-36.84973</td>
</tr>
<tr class="even">
<td style="text-align: center;">992032</td>
<td style="text-align: left;">14 Glen Close, Glen Eden, Auckland</td>
<td style="text-align: center;">2</td>
<td style="text-align: right;">174.6365</td>
<td style="text-align: right;">-36.91012</td>
</tr>
</tbody>
</table>
<p>We can spawn a new collector for each row by running something like:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala code-with-copy"><code class="sourceCode scala"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">implicit</span> <span class="kw">val</span> csvConfig <span class="op">=</span> <span class="fu">CsvConfig</span><span class="op">(</span><span class="st">"address_id"</span><span class="op">,</span> <span class="st">"full_address"</span><span class="op">,</span> <span class="st">"lng"</span><span class="op">,</span> <span class="st">"lat"</span><span class="op">,</span> <span class="st">"region"</span><span class="op">)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> cit <span class="op">=</span> <span class="fu">FieldCollectorIterator</span><span class="op">(</span><span class="st">"interviewers.csv.gz"</span><span class="op">)</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>cit<span class="op">.</span>hasNext<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  system <span class="op">!</span> cit<span class="op">.</span><span class="fu">next</span><span class="op">()</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For interest, the interviewer locations look as follows:</p>
<p><img src="assets/interviewers.png" class="img-fluid"></p>
</section>
<section id="spawn-dwellings" class="level2">
<h2 class="anchored" data-anchor-id="spawn-dwellings">Spawn Dwellings</h2>
<p>The process of spawning a dwelling actors is triggered by sending a message to the coordinator, defined as follows:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala code-with-copy"><code class="sourceCode scala"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="kw">class</span> <span class="fu">Dwelling</span><span class="op">(</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  id<span class="op">:</span> <span class="bu">Int</span><span class="op">,</span> address<span class="op">:</span> <span class="ex">String</span><span class="op">,</span> location<span class="op">:</span> Coordinates<span class="op">,</span> area<span class="op">:</span> <span class="ex">String</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="op">)</span> <span class="kw">extends</span> CoordinatorCommand <span class="kw">with</span> AreaCoordinatorCommand <span class="kw">with</span> FieldCollectorCommand</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This message is passed to the coordinator, the coordinator then forwards it to the correct area coordinator, and the area coordinator then decides which of its collectors to forward the message to. Additionally, when a dwelling is spawned, the field collector sends a message to the event recorder to be persisted. Visually:</p>
<p><img src="assets/dwelling.png" class="img-fluid"></p>
<p>The rule for deciding which specific field collector will be sent a particular dwelling is currently very simple, and works as follows:</p>
<ul>
<li>filter the list of collectors to the set with less than <code>$n$</code> cases already assigned</li>
<li>assign the dwelling to the closest (according to a routing service) remaining collector.</li>
</ul>
<p>Like collectors, dwellings can be provided by a CSV (or gzipped CSV) file, and an iterator can be used to read such files row-by-row, converting each row to an instance of <code>Dwelling</code>, and passing it to the coordinator. For example, say we had a file called <code>dwellings.csv.gz</code>, and the first few rows looked as follows:</p>
<table class="table">
<colgroup>
<col style="width: 12%">
<col style="width: 48%">
<col style="width: 7%">
<col style="width: 15%">
<col style="width: 15%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">address_id</th>
<th style="text-align: left;">full_address</th>
<th style="text-align: center;">region</th>
<th style="text-align: right;">lng</th>
<th style="text-align: right;">lat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">2186256</td>
<td style="text-align: left;">75B Insoll Avenue, Enderley, Hamilton</td>
<td style="text-align: center;">03</td>
<td style="text-align: right;">175.2944</td>
<td style="text-align: right;">-37.76214</td>
</tr>
<tr class="even">
<td style="text-align: center;">814042</td>
<td style="text-align: left;">7 Bertram Street, Hillcrest, Rotorua</td>
<td style="text-align: center;">04</td>
<td style="text-align: right;">176.2322</td>
<td style="text-align: right;">-38.14669</td>
</tr>
<tr class="odd">
<td style="text-align: center;">695912</td>
<td style="text-align: left;">114 Naylor Street, Hamilton East, Hamilton</td>
<td style="text-align: center;">03</td>
<td style="text-align: right;">175.3075</td>
<td style="text-align: right;">-37.79751</td>
</tr>
<tr class="even">
<td style="text-align: center;">1283168</td>
<td style="text-align: left;">46 Mako Street, Oneroa, Waiheke Island</td>
<td style="text-align: center;">02</td>
<td style="text-align: right;">175.0076</td>
<td style="text-align: right;">-36.78458</td>
</tr>
<tr class="odd">
<td style="text-align: center;">336865</td>
<td style="text-align: left;">85 Wither Road, Witherlea, Blenheim</td>
<td style="text-align: center;">18</td>
<td style="text-align: right;">173.9541</td>
<td style="text-align: right;">-41.53808</td>
</tr>
<tr class="even">
<td style="text-align: center;">336339</td>
<td style="text-align: left;">1/11 Milford Street, Witherlea, Blenheim</td>
<td style="text-align: center;">18</td>
<td style="text-align: right;">173.9540</td>
<td style="text-align: right;">-41.53505</td>
</tr>
</tbody>
</table>
<p>Then we could spawn a new collector for each row by running something like:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala code-with-copy"><code class="sourceCode scala"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">implicit</span> <span class="kw">val</span> csvConfig <span class="op">=</span> <span class="fu">CsvConfig</span><span class="op">(</span><span class="st">"address_id"</span><span class="op">,</span> <span class="st">"full_address"</span><span class="op">,</span> <span class="st">"lng"</span><span class="op">,</span> <span class="st">"lat"</span><span class="op">,</span> <span class="st">"region"</span><span class="op">)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> dit <span class="op">=</span> <span class="fu">DwellingIterator</span><span class="op">(</span><span class="st">"dwellings.csv.gz"</span><span class="op">)</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>dit<span class="op">.</span>hasNext<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  system <span class="op">!</span> dit<span class="op">.</span><span class="fu">next</span><span class="op">()</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>A number of sample files are provided along with the <a href="https://github.com/cmhh/collectionsim">simulation source</a>. For example <a href="https://github.com/cmhh/collectionsim/raw/main/data/sample1_01.csv.gz">sample1_01.csv.gz</a> and <a href="https://github.com/cmhh/collectionsim/raw/main/data/sample1_02.csv.gz">sample1_02.csv.gz</a> both consist of roughly 1600 locations each, but one is the result of a two-stage selection and one is a simple random sample, the result being the latter is more spatially dispersed. Spatially, the two samples look as follows:</p>
<p><img src="assets/dwellings.png" class="img-fluid"></p>
<p>Note that these two samples give us the opportunity to look a little at the plausibility of our simulation outcomes. All else constant, we’d expect collectors to have to travel more to service the non-clustered sample, and probably require more days to finish their workload overall as a result.</p>
</section>
<section id="spawn-individuals" class="level2">
<h2 class="anchored" data-anchor-id="spawn-individuals">Spawn Individuals</h2>
<p>Immediately after being spawned, a dwelling actor will then spawn a random collection of individual actors, or else remain empty / vacant. The process proceeds as follows…</p>
<p>Firstly, with some probability (default of 0.1), we decide the dwelling is empty, and do nothing.</p>
<p>For non-empty dwellings, the first step is to assign a <em>household type</em>. This is done randomly from the following discrete distribution (the default probabilities are drawn for the <a href="https://www.stats.govt.nz/methods/families-and-households-in-the-2018-census-data-sources-family-coding-and-data-quality">2018 Census</a>):</p>
<table class="table">
<thead>
<tr class="header">
<th>household type</th>
<th style="text-align: right;">probability</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>one-person household</td>
<td style="text-align: right;">0.2274</td>
</tr>
<tr class="even">
<td>one-family household</td>
<td style="text-align: right;">0.6862</td>
</tr>
<tr class="odd">
<td>two-family household</td>
<td style="text-align: right;">0.0352</td>
</tr>
<tr class="even">
<td>other multi-person household</td>
<td style="text-align: right;">0.0512</td>
</tr>
</tbody>
</table>
<p>In the case of a one-person household, a single individual is randomly generated. This process involves generating a random name, sex, and a random birth-date which makes the person at least 18 years of age (using the current system time&amp;endash;this could, of course, be modified). In the case of a multi-person household, we simply generate a random number of individuals in the same way.</p>
<p>In the case of a one-family household, we randomly generate a ‘family’, and for a two-family household, we randomly generate two. To generate a family, we first generate a random family type according to the following distribution:</p>
<table class="table">
<thead>
<tr class="header">
<th>family type</th>
<th style="text-align: right;">probability</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>couple only</td>
<td style="text-align: right;">0.3725</td>
</tr>
<tr class="even">
<td>couple only and others</td>
<td style="text-align: right;">0.0376</td>
</tr>
<tr class="odd">
<td>couple with children</td>
<td style="text-align: right;">0.3985</td>
</tr>
<tr class="even">
<td>couple with children and others</td>
<td style="text-align: right;">0.0373</td>
</tr>
<tr class="odd">
<td>one parent with children</td>
<td style="text-align: right;">0.1247</td>
</tr>
<tr class="even">
<td>one parent with children and others</td>
<td style="text-align: right;">0.0293</td>
</tr>
</tbody>
</table>
<p>Children are simply random individuals with a random birth date which makes them less than 15-years of age, and who have a specified family name. The process for generating couples is <em>very</em> naive, being more illustrative than definitive&amp;endash;we simply generate a male and female with a common surname, and who are within <code>$\pm$</code> 5 years of age of each other.</p>
</section>
<section id="simulating-a-days-work" class="level2">
<h2 class="anchored" data-anchor-id="simulating-a-days-work">Simulating a Day’s Work</h2>
<p>We kick off a simulated day of work by passing the coordinator a message defined as follows:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala code-with-copy"><code class="sourceCode scala"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="kw">class</span> <span class="fu">RunDay</span><span class="op">(</span>datetime<span class="op">:</span> LocalDateTime<span class="op">)</span> </span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">extends</span> CoordinatorCommand <span class="kw">with</span> AreaCoordinatorCommand <span class="kw">with</span> FieldCollectorCommand</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This message is then forwarded to each area coordinator, and each area coordinator then forwards it to each of their collectors. For example:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala code-with-copy"><code class="sourceCode scala"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>system <span class="op">!</span> <span class="fu">RunDay</span><span class="op">(</span>LocalDateTime<span class="op">.</span><span class="fu">of</span><span class="op">(</span><span class="dv">2022</span><span class="op">,</span><span class="dv">01</span><span class="op">,</span><span class="dv">10</span><span class="op">,</span><span class="dv">9</span><span class="op">,</span><span class="dv">0</span><span class="op">))</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><img src="assets/runday.png" class="img-fluid"></p>
<p>Each field collector will then proceed to work through their assigned dwelling cases, assuming a start time of 9:00 am on January 10, 2022. For each field collector, this means…</p>
<p>A field collector first subsets cases to those that are active. The active cases are placed in driving order by appealing to a routing service, and attempted one-by-one. This means travelling to the address of each case, attempting to interview the dwelling and any residents, and then moving to the next. The total minutes spent interviewing and total distance travelled are tracked, and if the maximum allowable minutes an interviewer can work in any day has been exceeded, the interviewer will return home, rather than travel to the next case. Each time a field collector travels to a new address, a record representing the trip, including origin and destination coordinates, departure and arrival time, and distance travelled is sent to the event recorder to persist. Likewise, all attempts to interview a dwelling or individual–the time the attempt is made, along with the outcome–is logged with the event recorder.</p>
<p>If a dwelling response has not been previously obtained, then the field collector sends an <code>AttemptInterview</code> message to the dwelling, and the dwelling responds with <code>DwellingRefusal</code>, <code>DwellingNoncontact</code>, or <code>DwellingResponse</code>. If <code>DwellingRefusal</code>, the case is marked as complete, and no further attempts will be made. If <code>DwellingNoncontact</code>, the collector moves on to the next case. If <code>DwellingResponse</code>, the dwelling will also send a list of any individuals it has spawned, and the collector will then attempt those in turn. Along with the list of individuals, a dwelling will also send a payload representing a completed household questionnaire (just a random string for now), which the collector will then forward to the event recorder to persist. If a dwelling response has been previously obtained, then the collector will already have a list of available individuals, and so they will be attempted directly, and no message will be sent to the dwelling.</p>
<p><img src="assets/dwelling_response.png" class="img-fluid"></p>
<p>Like dwellings, individuals will each be sent an <code>AttemptInterview</code> message, and they will respond with any of <code>IndividualRefusal</code>, <code>IndividualNoncontact</code>, or <code>IndividualResponse</code>. If <code>IndividualRefusal</code>, the individual will be marked as complete, and no further attempts will be made. If <code>IndividualNoncontact</code>, the collector will move on to the next individual, but the non-contact will remain active, and so future interview attempts will be made. If <code>IndividualResponse</code>, a payload representing a completed personal questionnaire will be sent as part of the message, which the collector will then forward to the event recorder to persist. The individual will be marked as complete, and no future interviews will be attempted.</p>
<p><img src="assets/individual_response.png" class="img-fluid">&nbsp;</p>
<p>When finished with a particular dwelling, field collectors send themselves a <code>NextItem</code> message. When received, collectors will remove the current case from the pool of outstanding work, and send an <code>AttemptInterview</code> message to the next available case (to the dwelling if no response has yet been received, or to the next unfinished individual). When moving to the next case, collectors increment a <code>dayKms</code> variable (if travelling), and a <code>dayMins</code> variable as appropriate.</p>
<p>At any point, ff there is no more work, or if <code>dayMins</code> exceeds some pre-configured amount of time in the day, the collector sends themselves the <code>GoHome</code> message. When this message is received, the route home is calculated and <code>dayKms</code> and <code>dayMins</code> are incremented, the pool of work is emptied, and no further messages are sent.</p>
</section>
</section>
<section id="analysing-the-simulated-data" class="level1">
<h1>Analysing the Simulated Data</h1>
<p>When a simulation is run, a SQLite database is used by the system’s event recorder. This database remains once the simulation has completed, and can be used to analyse the simulation after the fact. For example, above we noted that the samples <a href="https://github.com/cmhh/collectionsim/raw/main/data/sample1_02.csv.gz">sample1_02.csv.gz</a> is more spatially dispersed than <a href="https://github.com/cmhh/collectionsim/raw/main/data/sample1_01.csv.gz">sample1_01.csv.gz</a>, and so we would expect this sample to require more time and travel, all else constant. We can check this (in R, for convenience) quite directly:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(RSQLite)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>db1 <span class="ot">&lt;-</span> <span class="fu">dbConnect</span>(RSQLite<span class="sc">::</span><span class="fu">SQLite</span>(), <span class="st">"collectionsim1.db"</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>db2 <span class="ot">&lt;-</span> <span class="fu">dbConnect</span>(RSQLite<span class="sc">::</span><span class="fu">SQLite</span>(), <span class="st">"collectionsim2.db"</span>)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>kms1 <span class="ot">&lt;-</span> DBI<span class="sc">::</span><span class="fu">dbGetQuery</span>(db1, <span class="st">"select sum(distance) / 1000 from trips"</span>)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>kms2 <span class="ot">&lt;-</span> DBI<span class="sc">::</span><span class="fu">dbGetQuery</span>(db2, <span class="st">"select sum(distance) / 1000 from trips"</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="fu">as.numeric</span>(kms2 <span class="sc">/</span> kms1)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>DBI<span class="sc">::</span><span class="fu">dbDisconnect</span>(db1)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>DBI<span class="sc">::</span><span class="fu">dbDisconnect</span>(db2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>[1] 1.481211</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>That is, for one particular instance, the total distance travelled by all collectors was roughly 1.5 times greater for <a href="https://github.com/cmhh/collectionsim/raw/main/data/sample1_02.csv.gz">sample1_02.csv.gz</a> than <a href="https://github.com/cmhh/collectionsim/raw/main/data/sample1_01.csv.gz">sample1_01.csv.gz</a>.</p>
<p>In addition to this, we can create interactive tools using the simulated data. For example, the following is a screen grab of a simple <a href="https://shiny.rstudio.com/">Shiny</a> application which can be used to look at daily work for each collector by day:</p>
<p><img src="assets/trips1.webp" class="img-fluid"></p>
<p>The following screen-grab is the same application, but configured to use a routing service to get the paths for trips, rather than drawing simple straight lines:</p>
<p><img src="assets/trips2.webp" class="img-fluid"></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>