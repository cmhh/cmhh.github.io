---
title: "Routing in R Using the Open Source Routing Machine (OSRM)"
author: "Chris Hansen"
date: "2016-11-27"
archives: "2016"
slug: ["osrmr"]
categories: ["R", "geospatial", "OSRM"]
tags: ["R", "geospatial", "OSRM"]
knitr:
  opts_chunk:
    comment: ""
    echo: true
    cache: false
    fig.align: "center"
    warning: false
    message: false
description: "I often find myself needing to establish the travel time or distance between arrays of addresses from R.  Here we describe how we can use a local install of Open Source Routing Machine as a solution which is highly performant, and relatively easy to implement."
image: "assets/route.png"
---

```{r}
#| echo: false
params <- list()
keys <- readLines("keys.txt")
params$app_id <-  keys[1]
params$app_code <- keys[2]
```

# Overview

**Edit 2020-07-16**: The original version of this post included a bespoke decoder for geometries encoded as Google polylines.  The post has been updated to use the `googlePolylines` package instead.

I often find myself needing to establish the travel time or distance between arrays of addresses.  In the past I have used ArcMap's Network Analyst tool, but have found the syntax to be clunky at best, and the performance to be very mediocre.  And, besides, I am often working in R and sometimes it's nice to be able to do everything in the one environment, rather than doing the routing in Python, say, and then using the results in R.  

The [open source routing machine](http://project-osrm.org/) is a very fast routing engine which can be accessed via an [HTTP API](https://github.com/Project-OSRM/osrm-backend/blob/master/docs/http.md), which means it can be queried relatively easy from most languages, including R.  And while public servers are available for use, it is also relatively easy to set up locally resulting in excellent throughput due to the lack of latency.


# Prerequisites

The following R packages are required:

* `rjson` for reading web service results in JSON format
* `bitops` used to decode polylines (has convenient bitshift operators, etc.)
* `sp` for spatial projections, etc.
* `leaflet` for rendering <a href="http://leafletjs.com/">leaflet</a> maps in a browser
* `googlePolylines` for converting routes returned from OSRM to `sp`-compatible paths
  

# Geocoding addresses

The [HERE Geocoding & Search](https://developer.here.com/products/geocoding-and-search) API is used to geocode addresses.  Usage is free, but the free license is limited to 1000 requests per day, at a rate no faster than 5 per second.  There are free alternatives, but I've not found any that are satisfactorally accurate for New Zealand addresses.  That said, interesting alternatives worth keeping an eye on are:

* [data science toolkit](http://www.datasciencetoolkit.org/) - doesn't work at all for New Zealand
* [Nominatim](http://wiki.openstreetmap.org/wiki/Nominatim) - finds addresses but probably only okay if approximate locations are acceptable.
  
The following code results in two addresses being geocoded which we will use as an origin and a destination later when using a routing service.

```{r geocode}
library(rjson)

# use HERE API to geocode a start point...
get_location <- function(
  search_text,
  app_id = params$app_id, 
  app_code = params$app_code
) {
  service <- "https://geocoder.api.here.com/6.2/geocode.json"
  
  query <- sprintf(
    "%s?app_id=%s&app_code=%s&searchtext=%s",
    service, app_id, app_code,
    gsub(" ", "%20", search_text, fixed = TRUE)
  )

  res1 <- jsonlite::fromJSON(query, simplifyVector = FALSE)
  res2 <- res1$Response$View[[1]]$Result[[1]]$Location

  list(
    lng = res2$DisplayPosition$Longitude, 
    lat = res2$DisplayPosition$Latitude, 
    address = res2$Address$Label
  )
}

# start point...
(o <- get_location("25 Edelweiss Grove, Timberlea, Upper Hutt"))

# ...and destination
(d <- get_location("1 Pipitea Street, Wellington"))
```


# Open Source Routing Machine (OSRM)

[Open Source Routing Machine](http://project-osrm.org/) is an open source route solver.  It is written in C++ and runs on Linux (maybe other
platforms, but stick with Linux), and is very fast.  There is a nice web demo which uses the service as a back-end [here](http://map.project-osrm.org).  The back-end service is available to the public at [https://router.project-osrm.org](https://router.project-osrm.org).  Details, including usage policy, is available [here](https://github.com/Project-OSRM/osrm-backend/wiki/API Usage Policy). 

The code below shows how to find a route between the origin and destination locations found above:

```{r route}
url <- paste0(
  "https://router.project-osrm.org/route/v1/driving/",
  o$lng,",",o$lat,";",d$lng,",",d$lat,"?overview=full"
)

route <- jsonlite::fromJSON(url, simplifyVector = FALSE)
```

Again, assuming a route was successfully found, `route` will now contain a list including, among other things, time in seconds to traverse the route, distance in metres, and the route geometry stored in [encoded polyline algorithm format](https://developers.google.com/maps/documentation/utilities/polylinealgorithm).

```{r summary}
route$routes[[1]]$duration
route$routes[[1]]$distance
route$routes[[1]]$geometry
```

We then call a function to convert the encoded route to a `SpatialLines` object:

```{r decode}
path <- googlePolylines::decode(route$routes[[1]]$geometry)[[1]]
```
```{r plot} 
#| echo: false
plot(path$lon, path$lat, type = "l"); axis(1); axis(2); box()
```

# Using `leaflet` to make a nicer map

It is relatively easy to make a nice interactive map.  Here we draw a simple [leaflet](http://leafletjs.com/) map, and overlay the origin and destination points, as well as the route between.

```{r makemap}
library(leaflet)

#make a string to nicely label the route
s <- route$routes[[1]]$duration
kms <- round(route$routes[[1]]$distance/1000, 1)
routelabel <- paste0(s%/%60, "m ", s%%60, "s , ", kms, "kms")

#create a basic map
m <- leaflet(width="100%") %>% 
  addTiles()  %>% 
  addPolylines(
    lng = path$lon,
    lat = path$lat,
    popup = routelabel, 
    color = "#000000", 
    opacity = 1, 
    weight = 3
  ) %>%
  addMarkers(lng=o$lng, lat=o$lat, popup=o$address) %>%
  addMarkers(lng=d$lng, lat=d$lat, popup=d$address)
```
```{r plotmap}
#| echo: false
m
```

It's also relatively straight forward to use different base maps, and a nice demo of some other providers can be found [here](http://leaflet-extras.github.io/leaflet-providers/preview/).  For example:

```{r basemaps}
require(leaflet)

leaflet(width="100%") %>% 
  addTiles(
    urlTemplate='https://stamen-tiles-{s}.a.ssl.fastly.net/watercolor/{z}/{x}/{y}.png',
    attribution = sprintf(
      "Map tiles by %s", 
      '<a href="http://stamen.com">Stamen Design</a>'
    )
  ) %>%
  addTiles(
    urlTemplate = 'https://stamen-tiles-{s}.a.ssl.fastly.net/toner-hybrid/{z}/{x}/{y}{r}.png'
  ) %>%
  addPolylines(
    lng = path$lon,
    lat = path$lat,
    popup=routelabel, 
    color = "#000000", 
    opacity = 1, 
    weight = 3
  ) %>%
  addMarkers(lng = o$lng, lat = o$lat, popup = o$address) %>%
  addMarkers(lng = d$lng, lat = d$lat, popup = d$address)
```
